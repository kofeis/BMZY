{"version":3,"sources":["file:///D:/CYDW/WoChengYuTeNiu/assets/Script/Other/Tool_Script.ts"],"names":[],"mappings":"AAAA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAEA;AACA;AACA;AACA;AAEA","sourcesContent":["// import { _decorator, Component, Node, Vec2, Vec3, tween, v3, Sprite, UITransform, color, Rect, Label, sys, Prefab, SpriteFrame, instantiate, Texture2D, Material, log, Color, view, Animation, sp, Tween, Button, NodeEventType, director, macro, input, Input, Constructor, UIOpacity, __private, AnimationState, assetManager, AudioClip, AudioSource, isValid } from 'cc';\r\n// const { ccclass, property } = _decorator;\r\n\r\n// @ccclass('Tool_Script')\r\n// export class Tool_Script extends Component {\r\n\r\n\r\n//     public static readonly instance = new Tool_Script();\r\n\r\n\r\n//     /**\r\n//      * 数据区\r\n//      * 事件区\r\n//      * 功能区\r\n//      * 动画区\r\n//      * 其他区\r\n//      */\r\n\r\n\r\n\r\n//     /**\r\n//      *@param 数据保存本地\r\n//      *@Data_Name 待保存数据的名字\r\n//      *@Data_Name 待保存的数据\r\n//      */\r\n//     Set_Data(Data_Name: string, Data) {\r\n//         sys.localStorage.setItem(Data_Name, JSON.stringify(Data));\r\n//     }\r\n//     /**\r\n//      *@param 读取本地数据\r\n//      *@Data_Name 待读取数据的名字\r\n//      */\r\n//     Get_Data(Data_Name: string) {\r\n//         let Data = sys.localStorage.getItem(Data_Name);\r\n//         return JSON.parse(Data);\r\n//     }\r\n\r\n   \r\n//     /**延时等待 */\r\n//     Delay_Time(Time: number): Promise<void> {\r\n//         return new Promise((resolve, reject) => {\r\n//             this.scheduleOnce(() => {\r\n//                 resolve();\r\n//             }, Time);\r\n//         })\r\n//     }\r\n\r\n//     /**获取组件 */\r\n//     Get_Component<T extends Component>(Get_Node: Node, Class_Constructor: Constructor<T>): T | null {\r\n//         if (!Get_Node || !Get_Node.isValid) return null;\r\n//         let component = Get_Node.getComponent(Class_Constructor);\r\n//         if (!component)\r\n//             component = Get_Node.addComponent(Class_Constructor);\r\n//         return component;\r\n//     }\r\n\r\n//     /**获取Target_Node在Set_Node坐标系下的本地坐标 */\r\n//     Get_Pos_Local(Set_Node: Node, Target_Node: Node) {\r\n//         // 获取Target_Node的世界坐标\r\n//         const Pos_World = Target_Node.getComponent(UITransform).convertToWorldSpaceAR(v3(0, 0, 0));\r\n//         // 将Set_Node的世界坐标转换为Target_Node的本地坐标\r\n//         const Pos_Local = Set_Node.parent.getComponent(UITransform).convertToNodeSpaceAR(Pos_World);\r\n//         return Pos_Local;\r\n//     }\r\n\r\n//     /**\r\n//      * 设置父节点\r\n//      * @param Set_Node 设置的节点\r\n//      * @param Parent_Node 原父节点\r\n//      * @param Target_Node 新父节点\r\n//      */\r\n//     Set_Parent(Set_Node: Node, Parent_Node: Node, Target_Node: Node) {\r\n//         //设置父节点\r\n//         Set_Node.parent = Target_Node;\r\n//         //获取Set_Node世界坐标\r\n//         const Pos_World = Parent_Node.getComponent(UITransform).convertToWorldSpaceAR(Set_Node.position);\r\n//         //将世界坐标转换本地坐标\r\n//         const Pos_Local = Set_Node.parent.getComponent(UITransform).convertToNodeSpaceAR(Pos_World);\r\n//         console.log(Pos_Local);\r\n\r\n//         Set_Node.position = Pos_Local;\r\n\r\n//     }\r\n\r\n\r\n//     /**设置坐标一致 */\r\n//     Set_Pos_Word_Same(Set_Node: Node, Target_Node: Node) {\r\n//         Set_Node.setWorldPosition(this.Get_Pos_Word(Target_Node));\r\n//     }\r\n//     /**设置世界坐标 */\r\n//     Set_Pos_Word(Set_Pos: Vec3, Target_Node: Node) {\r\n//         Target_Node.setWorldPosition(Set_Pos);\r\n//     }\r\n//     /**获取世界坐标 */\r\n//     Get_Pos_Word(Target_Node: Node) {\r\n//         return Target_Node.getWorldPosition(Target_Node.position);\r\n//     }\r\n\r\n//     /**监听触摸开始 */\r\n//     On_Btn_TOUCH_START(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.TOUCH_START, Call, Node);\r\n//     }\r\n//     /**监听触摸结束 */\r\n//     On_Btn_TOUCH_END(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.TOUCH_END, Call, Node);\r\n//     }\r\n//     /**监听触摸取消 */\r\n//     On_Btn_TOUCH_CANCEL(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.TOUCH_CANCEL, Call, Node);\r\n//     }\r\n//     /**监听触摸移动 */\r\n//     On_Btn_TOUCH_MOVE(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.TOUCH_MOVE, Call, Node);\r\n//     }\r\n//     /**监听触摸按住\r\n//      * @param Set_Node 监听节点\r\n//      * @param Response_Time 按住时长\r\n//      * @param Id 缓动Id\r\n//      * @param Pressing_Call 按住回调\r\n//      * @param Pressend_Call 松开\r\n//      */\r\n//     On_Btn_TOUCH_Pressing(Set_Node: Node, Response_Time: number, Id: number = 100, Pressing_Call: Function = () => { }, Pressend_Call: Function = () => { }) {\r\n//         Set_Node.on(NodeEventType.TOUCH_START, () => {\r\n//             let startObj = { num: 0 };\r\n//             let endObj = { num: 100 };\r\n//             tween(startObj)\r\n//                 .to(Response_Time, endObj, {\r\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                         return ratio;\r\n//                     }\r\n//                 })\r\n//                 .tag(Id)\r\n//                 .call(() => {\r\n//                     Pressing_Call && Pressing_Call();\r\n//                 })\r\n//                 .start();\r\n//         }, Set_Node);\r\n//         Set_Node.on(NodeEventType.TOUCH_END, () => {\r\n//             this.Stop_Tween_Tag(Id);\r\n//             Pressend_Call && Pressend_Call();\r\n//         }, Node);\r\n//         Set_Node.on(NodeEventType.TOUCH_CANCEL, () => {\r\n//             this.Stop_Tween_Tag(Id);\r\n//             Pressend_Call && Pressend_Call();\r\n//         }, Set_Node);\r\n//         Set_Node.on(NodeEventType.TOUCH_MOVE, (Event) => {\r\n\r\n//             // 获取浏览器窗口可见区域尺寸\r\n//             // let Screen_Width = window.innerWidth;\r\n//             // let Screen_Height = window.innerHeight;\r\n\r\n//             // let Touch_Pos = v3(Event.getUILocation().x - Screen_Width / 2, Event.getUILocation().y - Screen_Height / 2, Event.getUILocation().z);\r\n//             // console.log(Touch_Pos);\r\n\r\n//             this.Stop_Tween_Tag(Id);\r\n//             Pressend_Call && Pressend_Call();\r\n//         }, Node);\r\n//     }\r\n//     /**监听触摸双击\r\n//      * @param Set_Node 监听节点\r\n//      * @param Touch_Count_All 触摸总次数\r\n//      * @param Touch_Interval 触摸间隔\r\n//      * @param Id 缓动Id\r\n//      * @param Double_On_Call 双击回调\r\n//      * @param Double_Off_Call 松开回调\r\n//      */\r\n//     On_Btn_TOUCH_Double(Set_Node: Node, Touch_Count_All: number, Touch_Interval: number = 0.25, Id: number = 101, Double_On_Call: Function = () => { }, Double_Off_Call: Function = () => { }) {\r\n\r\n//         let Touch_Count: number = 0;\r\n\r\n//         Set_Node.on(NodeEventType.TOUCH_START, () => {\r\n//             this.Stop_Tween_Tag(Id);\r\n//             Touch_Count++;\r\n//             if (Touch_Count == Touch_Count_All) {\r\n//                 Touch_Count = 0;\r\n//                 Double_On_Call && Double_On_Call();\r\n//             }\r\n//             let startObj = { num: 0 };\r\n//             let endObj = { num: 100 };\r\n//             tween(startObj)\r\n//                 .to(Touch_Interval, endObj, {\r\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                         return;\r\n//                     }\r\n//                 })\r\n//                 .tag(Id)\r\n//                 .call(() => {\r\n//                     Touch_Count = 0;\r\n//                 })\r\n//                 .start();\r\n//         }, Set_Node);\r\n//         // Set_Node.on(NodeEventType.TOUCH_END, () => {\r\n//         //     this.Stop_Tween_Tag(101);\r\n//         //     Double_Off_Call && Double_Off_Call();\r\n//         // }, Node);\r\n//         // Set_Node.on(NodeEventType.TOUCH_CANCEL, () => {\r\n//         //     this.Stop_Tween_Tag(101);\r\n//         //     Double_Off_Call && Double_Off_Call();\r\n//         // }, Set_Node);\r\n//     }\r\n//     /**取消触摸监听 */\r\n//     Off_Btn_TOUCH(Node: Node, Call: Function = () => { }) {\r\n//         Node.off(NodeEventType.TOUCH_START, Call, Node);\r\n//         Node.off(NodeEventType.TOUCH_END, Call, Node);\r\n//         Node.off(NodeEventType.TOUCH_CANCEL, Call, Node);\r\n//         Node.off(NodeEventType.TOUCH_MOVE, Call, Node);\r\n//     }\r\n//     /**取消所有触摸监听 */\r\n//     Off_Btn_TOUCH_All(Node: Node) {\r\n//         Node.off(NodeEventType.TOUCH_START);\r\n//         Node.off(NodeEventType.TOUCH_END);\r\n//         Node.off(NodeEventType.TOUCH_CANCEL);\r\n//         Node.off(NodeEventType.TOUCH_MOVE);\r\n//     }\r\n\r\n\r\n//     /**监听鼠标按下 */\r\n//     On_Btn_MOUSE_DOWN(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.MOUSE_DOWN, Call, Node);\r\n//     }\r\n//     /**监听鼠标松开 */\r\n//     On_Btn_MOUSE_UP(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.MOUSE_UP, Call, Node);\r\n//     }\r\n//     /**监听鼠标移动 */\r\n//     On_Btn_MOUSE_MOVE(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.MOUSE_MOVE, Call, Node);\r\n//     }\r\n//     /**监听鼠标滚动 */\r\n//     On_Btn_MOUSE_WHEEL(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.MOUSE_WHEEL, Call, Node);\r\n//     }\r\n//     /**监听鼠标进入 */\r\n//     On_Btn_MOUSE_ENTER(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.MOUSE_ENTER, Call, Node);\r\n//     }\r\n//     /**监听鼠标移出 */\r\n//     On_Btn_MOUSE_LEAVE(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.MOUSE_LEAVE, Call, Node);\r\n//     }\r\n\r\n//     /**监听键盘按下 */\r\n//     On_KEY_DOWN(Call: Function = () => { }) {\r\n//         input.on(Input.EventType.KEY_DOWN, Call(), this);\r\n//     }\r\n//     /**监听键盘按住 */\r\n//     On_KEY_PRESSING(Call: Function = () => { }) {\r\n//         input.on(Input.EventType.KEY_PRESSING, Call(), this);\r\n//     }\r\n//     /**监听键盘松开 */\r\n//     On_KEY_UP(Call: Function = () => { }) {\r\n//         input.on(Input.EventType.KEY_UP, Call(), this);\r\n//     }\r\n\r\n//     /**监听重力感应 */\r\n//     On_Sys_DEVICEMOTION(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(Input.EventType.DEVICEMOTION, Call, Node);\r\n//     }\r\n\r\n//     /**设置按钮事件\r\n//      * @Set_Node 待设置的节点\r\n//      * @Target_Node 目标节点\r\n//      * @Component 脚本/组件名\r\n//      * @Handler  响应事件函数名\r\n//      */\r\n//     Set_Btn_Event_Add(Set_Node: Node, Target_Node: Node, Scr_Name: string, Fun_Name: string, CustomEventData = null) {\r\n//         let Btn = Set_Node.getComponent(Button);\r\n//         if (!this.Get_Type_Is_Abnormal(Btn)) {\r\n//             Btn = Set_Node.addComponent(Button);\r\n//         }\r\n//         let Opacity = Set_Node.getComponent(UIOpacity);\r\n//         if (!this.Get_Type_Is_Abnormal(Opacity)) {\r\n//             Set_Node.addComponent(UIOpacity);\r\n//         }\r\n\r\n//         let Event = new Component.EventHandler();\r\n//         Event.target = Target_Node;\r\n//         Event.component = Scr_Name;\r\n//         Event.handler = Fun_Name;\r\n//         Event.customEventData = CustomEventData;\r\n//         Btn.clickEvents.push(Event);\r\n//         console.info(Btn.clickEvents);\r\n//     }\r\n//     /**设置按钮动画\r\n//      * @Anim_Switch 动画开关 \r\n//      */\r\n//     Set_Btn_Event_Anim(Set_Node: Node, Anim_Switch: boolean = false) {\r\n//         let Btn = Set_Node.getComponent(Button);\r\n//         if (!this.Get_Type_Is_Abnormal(Btn)) {\r\n//             Btn = Set_Node.addComponent(Button);\r\n//         }\r\n//         let Opacity = Set_Node.getComponent(UIOpacity);\r\n//         if (!this.Get_Type_Is_Abnormal(Opacity)) {\r\n//             Set_Node.addComponent(UIOpacity);\r\n//         }\r\n\r\n//         if (Anim_Switch) {\r\n//             this.Off_Btn_TOUCH(Set_Node);\r\n//             Btn.transition = 0;\r\n//             let Anim_State = false;\r\n//             Set_Node.off(NodeEventType.TOUCH_START, () => {\r\n//                 if (Anim_State) {\r\n//                     return;\r\n//                 }\r\n//                 Anim_State = true;\r\n//                 Anim_On(Set_Node);\r\n//             }, Set_Node);\r\n//             this.On_Btn_TOUCH_START(Set_Node, () => {\r\n//                 if (Anim_State) {\r\n//                     return;\r\n//                 }\r\n//                 Anim_State = true;\r\n//                 Anim_On(Set_Node);\r\n//             })\r\n//             this.On_Btn_TOUCH_END(Set_Node, () => {\r\n//                 if (!Anim_State) {\r\n//                     return;\r\n//                 }\r\n//                 Anim_State = false;\r\n//                 Anim_Off(Set_Node);\r\n//             })\r\n//             this.On_Btn_TOUCH_CANCEL(Set_Node, () => {\r\n//                 if (!Anim_State) {\r\n//                     return;\r\n//                 }\r\n//                 Anim_State = false;\r\n//                 Anim_Off(Set_Node);\r\n//             })\r\n//             this.On_Btn_TOUCH_MOVE(Set_Node, (Event) => {\r\n//                 // console.log(Event.getUILocation());\r\n//                 // console.log(Event);\r\n//                 let Target_Width = Event.target.getComponent(UITransform).width;\r\n//                 let Target_Height = Event.target.getComponent(UITransform).height;\r\n//                 let Touch_Pos_World = v3(Event.getUILocation().x, Event.getUILocation().y, Event.getUILocation().z);\r\n//                 let Target_Pos_World = Event.target.getWorldPosition();\r\n//                 if (Touch_Pos_World.x < Target_Pos_World.x - Target_Width / 2 || Touch_Pos_World.x > Target_Pos_World.x + Target_Width / 2 || Touch_Pos_World.y < Target_Pos_World.y - Target_Height / 2 || Touch_Pos_World.y > Target_Pos_World.y + Target_Height / 2) {\r\n//                     if (!Anim_State) {\r\n//                         return;\r\n//                     }\r\n//                     Anim_State = false;\r\n//                     Anim_Off(Set_Node);\r\n//                 } else {\r\n//                     if (Anim_State) {\r\n//                         return;\r\n//                     }\r\n//                     Anim_State = true;\r\n//                     Anim_On(Set_Node);\r\n//                 }\r\n//             })\r\n//         } else {\r\n//             Btn.transition = 3;\r\n//             Btn.zoomScale = 0.975;\r\n//             Btn.duration = 0.05;\r\n//         }\r\n//         // function Anim_On(Set_Node) {\r\n//         //     console.log(\"按下\");\r\n//         //     let Time = 0.25;\r\n//         //     tween(Set_Node)\r\n//         //         .to(Time, { scale: v3(0.8, 0.8, 1) })\r\n//         //         .start();\r\n//         //     tween(Set_Node.getComponent(UIOpacity))\r\n//         //         .to(Time, { opacity: 100 })\r\n//         //         .start();\r\n//         // }\r\n\r\n//         // function Anim_Off(Set_Node) {\r\n//         //     console.log(\"松开\");\r\n//         //     tween(Set_Node)\r\n//         //         .to(0.17, { scale: v3(1.05, 1.05, 1) })\r\n//         //         .to(0.08, { scale: v3(1, 1, 1) })\r\n//         //         .start();\r\n//         //     tween(Set_Node.getComponent(UIOpacity))\r\n//         //         .to(0.25, { opacity: 255 })\r\n//         //         .start();\r\n//         // }\r\n//         function Anim_On(Set_Node) {\r\n//             console.log(\"按下\");\r\n//             let Time = 0.15;\r\n//             tween(Set_Node)\r\n//                 .to(Time, { scale: v3(0.95, 0.95, 1) })\r\n//                 .start();\r\n//             tween(Set_Node.getComponent(UIOpacity))\r\n//                 .to(Time, { opacity: 200 })\r\n//                 .start();\r\n//         }\r\n\r\n//         function Anim_Off(Set_Node) {\r\n//             console.log(\"松开\");\r\n//             tween(Set_Node)\r\n//                 .to(0.1, { scale: v3(1.05, 1.05, 1) })\r\n//                 .to(0.05, { scale: v3(1, 1, 1) })\r\n//                 .start();\r\n//             tween(Set_Node.getComponent(UIOpacity))\r\n//                 .to(0.15, { opacity: 255 })\r\n//                 .start();\r\n//         }\r\n//     }\r\n\r\n\r\n//     /**重置按钮组件 */\r\n//     Set_Btn_Event_Reset(Node: Node) {\r\n//         let Btn = Node.getComponent(Button);\r\n//         if (!this.Get_Type_Is_Abnormal(Btn)) { return }\r\n//         Btn.resetInEditor();\r\n//     }\r\n\r\n//     // /**注册场景监听 */\r\n//     // On_Screen() {\r\n//     //     const CurrentScene = director.getScene();\r\n//     //     CurrentScene.on('window-resize', this.On_Window_Resize, this);\r\n//     //     CurrentScene.on('orientation-change', this.On_Orientation_Change, this);\r\n//     //     CurrentScene.on('fullscreen-change', this.On_Full_ScreenChange, this);\r\n//     // }\r\n//     // /**注销场景监听 */\r\n//     // Off_Screen() {\r\n//     //     const CurrentScene = director.getScene();\r\n//     //     CurrentScene.off('window-resize', this.On_Window_Resize, this);\r\n//     //     CurrentScene.off('orientation-change', this.On_Orientation_Change, this);\r\n//     //     CurrentScene.off('fullscreen-change', this.On_Full_ScreenChange, this);\r\n//     // }\r\n\r\n//     // /**监听窗口大小变化\r\n//     //  * @p 支持平台:网页、原生、小游戏\r\n//     //  */\r\n//     // On_Window_Resize(Width: number, Height: number) {\r\n//     //     console.log(\"Window resized:\");\r\n//     //     console.log(\"Width\", Width);\r\n//     //     console.log(\"Height\", Height);\r\n//     // }\r\n//     // /**监听屏幕方向变化\r\n//     //  * @p 支持平台:网页、原生\r\n//     //  */\r\n//     // On_Orientation_Change(orientation: number) {\r\n//     //     if (orientation === macro.ORIENTATION_LANDSCAPE_LEFT || orientation === macro.ORIENTATION_LANDSCAPE_RIGHT) {\r\n//     //         console.log(\"Orientation changed to landscape:\", orientation);//横屏\r\n//     //     } else {\r\n//     //         console.log(\"Orientation changed to portrait:\", orientation);//竖屏\r\n//     //     }\r\n//     // }\r\n//     /**监听全屏变化\r\n//      * @p 支持平台:网页\r\n//      */\r\n//     On_Full_ScreenChange(Width: number, Height: number) {\r\n//         console.log(\"Fullscreen change:\");\r\n//         console.log(\"Width\", Width);\r\n//         console.log(\"Height\", Height);\r\n//     }\r\n\r\n//     /**监听激活状态 */\r\n//     On_Node_Active_State(Node: Node, Call: Function = () => { }) {\r\n//         Node.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, Call, Node);\r\n//     }\r\n\r\n\r\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//     /**获取闭区间[Min,Max]内的随机数*/\r\n//     Get_Random_Int(Min: number, Max: number): number {\r\n//         Min = Math.ceil(Min);\r\n//         Max = Math.floor(Max);\r\n//         return Math.floor(Math.random() * (Max - Min + 1)) + Min;\r\n//     }\r\n\r\n//     /** 获取闭区间 [Min, Max] 内的数组 Arr 外的随机数，如果不存在返回 -1；\r\n//      * @param Min 最小数\r\n//      * @param Max 最大数\r\n//      * @param Arr 数组\r\n//      * @example Get_Random_Int_Plus(0, 6, [1, 2, 3, 4]); // return 0/5/6\r\n//      */\r\n//     Get_Random_Int_Plus(Min: number, Max: number, Arr: number[]): number {\r\n//         // 将数组 Arr 转换为 Set，以便快速查找\r\n//         const excludedNumbers = new Set(Arr);\r\n//         const availableNumbers: number[] = [];\r\n\r\n//         // 收集可用的数字\r\n//         for (let i = Min; i <= Max; i++) {\r\n//             if (!excludedNumbers.has(i)) {\r\n//                 availableNumbers.push(i);\r\n//             }\r\n//         }\r\n\r\n//         // 如果没有可用的数字，返回 -1\r\n//         if (availableNumbers.length === 0) {\r\n//             return -1;\r\n//         } else {\r\n//             // 获取随机索引并返回对应的随机数\r\n//             const randomIndex = this.Get_Random_Int(0, availableNumbers.length - 1);\r\n//             return availableNumbers[randomIndex];\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//      *获取一组不重复的数据\r\n//      *@param Min 最小数\r\n//      *@param Max 最大数\r\n//      *@param Lenth 数组长度\r\n//      */\r\n//     Get_Random_Number_Array(Min: number, Max: number, Length: number): number[] {\r\n//         // 确保 Length 不超过可用范围\r\n//         Length = Math.min(Length, (Max - Min) + 1);\r\n//         const result: Set<number> = new Set(); // 使用 Set 来避免重复\r\n//         while (result.size < Length) {\r\n//             const randomNum = this.Get_Random_Int(Min, Max);\r\n//             result.add(randomNum); // Set 会自动处理重复\r\n//         }\r\n//         return Array.from(result); // 将 Set 转换为数组\r\n//     }\r\n\r\n\r\n//     /**\r\n//      *@param 获取一个预制体\r\n//      *@param Prefab 预制体\r\n//      *@param Parent_Node 父节点\r\n//      *@param Position 坐标\r\n//      *@param SpriteFrame 精灵框架\r\n//      *@param Call 回调\r\n//      *@returns 返回此预制体\r\n//      */\r\n//     Get_Prefab_Plus(Prefab: Prefab, Parent_Node: Node, Position: Vec3, SpriteFrame: SpriteFrame, Call: Function = () => { }) {\r\n//         let Node: Node = instantiate(Prefab);\r\n//         Node.parent = Parent_Node;\r\n//         if (SpriteFrame != null) {\r\n//             Node.getComponent(Sprite).spriteFrame = SpriteFrame;\r\n//         }\r\n//         Node.setPosition(Position);\r\n//         Call && Call();\r\n//         return Node;\r\n//     }\r\n\r\n\r\n//     //时间--------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n//     /**秒数转时间字符串 */\r\n//     Seconds_To_Time_String(Seconds: number): string {\r\n//         const Hours = Math.floor(Seconds / 3600);\r\n//         const Minutes = Math.floor((Seconds % 3600) / 60);\r\n//         const Secs = Seconds % 60;\r\n//         // 手动格式化为两位数\r\n//         let FormattedHours = (Hours < 10 ? '0' : '') + Hours + \":\";\r\n//         if (Hours == 0) {\r\n//             FormattedHours = \"\";\r\n//         }\r\n//         let FormattedMinutes = (Minutes < 10 ? '0' : '') + Minutes + \":\";\r\n//         let FormattedSeconds = (Secs < 10 ? '0' : '') + Secs;\r\n//         return `${FormattedHours}${FormattedMinutes}${FormattedSeconds}`;\r\n//     }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n//     /**替换字符串中的所有字符\r\n//      *@将Str0中的Str1替换为Str2\r\n//      */\r\n//     Replace_All_Chars_InString(Str0: string, Str1: string, Str2: string): string {\r\n//         return Str0.replace(new RegExp(Str1, 'g'), Str2);\r\n//     }\r\n\r\n\r\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//     //动画区\r\n\r\n//     /**播放帧动画\r\n//      * @param Name 动画名字\r\n//      * @param Min_Range 播放范围\r\n//      * @param Max_Range 播放范围\r\n//      * @param Speed 播放速率\r\n//      * @param WrapMode 循环方式\r\n//      * @param RepeatCount 重复次数\r\n//      * @param Delay 延时时间\r\n//      * @param Call 回调\r\n//      */\r\n//     Anim_Frame_Play(Anim: Animation, Name: string = null, Speed: number = 1, Min_Range: number = null, Max_Range: number = null, WrapMode: __private._cocos_animation_types__WrapMode = null, RepeatCount: number = null, Delay: number = 0, Call: Function = () => { }) {\r\n//         if (Name == null) {\r\n//             if (Anim.defaultClip) {\r\n//                 Name = Anim.defaultClip.name;\r\n//             } else {\r\n//                 console.error(\"动画缺失\");\r\n//                 return;\r\n//             }\r\n//         }\r\n//         let State: AnimationState = Anim.getState(Name);\r\n//         if (WrapMode != null) {\r\n//             State.wrapMode = WrapMode;\r\n//         }\r\n//         if (RepeatCount != null) {\r\n//             State.repeatCount = RepeatCount;\r\n//         }\r\n//         if (Min_Range != null && Max_Range != null && Min_Range <= Max_Range) {\r\n//             State.playbackRange = {\r\n//                 min: Min_Range,\r\n//                 max: Max_Range\r\n//             }\r\n//         }\r\n//         State.delay = Delay;\r\n//         State.speed = Speed;\r\n\r\n//         Anim.play(Name);\r\n//         Anim.once(Animation.EventType.FINISHED, () => {\r\n//             Call && Call();\r\n//             // Anim.off(Animation.EventType.FINISHED);\r\n//         });\r\n//     }\r\n//     /**切换帧动画 */\r\n//     Anim_Frame_CrossFade(Anim: Animation, Name: string = null, Duration: number = 0, Call: Function = () => { }) {\r\n//         Anim.crossFade(Name, Duration);\r\n//         Anim.once(Animation.EventType.FINISHED, () => {\r\n//             Call && Call();\r\n//         });\r\n//     }\r\n//     /**恢复帧动画 */\r\n//     Anim_Frame_Resume(Anim: Animation, Name: string = null, Speed: number = 1, Min_Range: number = null, Max_Range: number = null, WrapMode: __private._cocos_animation_types__WrapMode = null, RepeatCount: number = null, Delay: number = 0, Call: Function = () => { }) {\r\n//         if (Name == null) {\r\n//             if (Anim.defaultClip) {\r\n//                 Name = Anim.defaultClip.name;\r\n//             } else {\r\n//                 console.error(\"动画缺失\");\r\n//                 return;\r\n//             }\r\n//         }\r\n//         let State: AnimationState = Anim.getState(Name);\r\n//         // console.log(\"是否已被暂停或停止:\", State.isMotionless);\r\n//         // console.log(\"是否已被暂停:\", State.isPaused);\r\n//         // console.log(\" 是否正在播放状态\", State.isPlaying);\r\n//         if (WrapMode != null) {\r\n//             State.wrapMode = WrapMode;\r\n\r\n//         }\r\n//         if (RepeatCount != null) {\r\n//             State.repeatCount = RepeatCount;\r\n//         }\r\n//         if (Min_Range != null && Max_Range != null && Min_Range <= Max_Range) {\r\n//             State.playbackRange = {\r\n//                 min: Min_Range,\r\n//                 max: Max_Range\r\n//             }\r\n//         }\r\n//         State.delay = Delay;\r\n//         State.speed = Speed;\r\n//         if (State.isPlaying) {\r\n//             if (State.isPaused) {\r\n//                 Anim.resume();\r\n//                 Anim.once(Animation.EventType.FINISHED, () => {\r\n//                     Call && Call();\r\n//                 });\r\n//             } else {\r\n//                 this.Anim_Frame_Pause(Anim);\r\n//             }\r\n//         } else {\r\n//             this.Anim_Frame_Play(Anim, Name, Speed, Min_Range, Max_Range, WrapMode, RepeatCount, Delay, Call);\r\n//         }\r\n//     }\r\n//     /**暂停帧动画 */\r\n//     Anim_Frame_Pause(Anim: Animation, Call: Function = () => { }) {\r\n//         Anim.pause();\r\n//         Anim.off(Animation.EventType.FINISHED);\r\n//         Call && Call();\r\n//     }\r\n//     /**停止帧动画 */\r\n//     Anim_Frame_Stop(Anim: Animation, Call: Function = () => { }) {\r\n//         Anim.stop();\r\n//         Anim.off(Animation.EventType.FINISHED);\r\n//         Call && Call();\r\n//     }\r\n\r\n\r\n//     /**播放骨骼动画 */\r\n//     Anim_Skeleton_Play(Skeleton: sp.Skeleton, Skin: string, Track_Index: number, Anim_Name: string, Loop: boolean, Call: Function = () => { }) {\r\n//         if (Skin == \"\") {\r\n//             Skin = \"default\"\r\n//         }\r\n//         Skeleton.setSkin(Skin);\r\n//         //@ts-ignore\r\n//         Skeleton._updateSkeletonData();\r\n//         Skeleton.setAnimation(Track_Index, Anim_Name, Loop);\r\n//         Skeleton.setCompleteListener(() => {\r\n//             Skeleton.setCompleteListener(null);\r\n//             Call && Call();\r\n//         })\r\n//     }\r\n\r\n//     /**溶解动画 */\r\n//     async Anim_Dissolve(Set_Node: Node, Time: number = 1, Call: Function = () => { }) {\r\n//         this.Bundles = await this.Load_Bundle(\"Load\");\r\n//         let Set_Material = await this.Load_Material(\"Effect/dissolve\");\r\n//         return new Promise<void>(res => {\r\n//             const Sp = Set_Node.getComponent(Sprite);\r\n//             if (!Sp.customMaterial) Sp.customMaterial = Set_Material;\r\n//             Sp.customMaterial.copy(Set_Material);\r\n//             Sp.customMaterial.setProperty('dissolveThreshold', 0);\r\n//             let startObj = { num: 0 };\r\n//             let endObj = { num: 100 };\r\n//             tween(startObj)\r\n//                 .to(Time, endObj, {\r\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                         const Current_Num = 1 * ratio;//0.3 + 0.7\r\n//                         Sp.customMaterial.setProperty('dissolveThreshold', Current_Num);\r\n//                         return Current_Num;\r\n//                     }\r\n//                 })\r\n//                 .call(() => {\r\n//                     res();\r\n//                     Call && Call();\r\n//                 })\r\n//                 .start();\r\n\r\n\r\n//         })\r\n//     }\r\n\r\n\r\n//     /**停止缓动标签 */\r\n//     Stop_Tween_Tag(Id: number, Call = () => { }) {\r\n//         Tween.stopAllByTag(Id);\r\n//         Call && Call();\r\n//     }\r\n\r\n//     Delay_Schedule(Delay: number, Id: number, Call = () => { }): void {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(Delay, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     return ratio;\r\n//                 }\r\n//             })\r\n//             .tag(Id)\r\n//             .call(() => {\r\n//                 Call && Call();\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n//     /**数字跳动 */\r\n//     Num_Jump(Label: Label, Value: number, Time: number, Id: number, Call = () => { }) {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         Value = Value / 100;\r\n//         tween(startObj)\r\n//             .to(Time, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     Label.string = (Number(ratio) * Value).toFixed(2);\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .tag(Id)\r\n//             .call(() => {\r\n//                 Call && Call();\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n\r\n//     /**动画_节点_移动\r\n//          *@Node 节点\r\n//          *@Position 位置\r\n//          *@Time 速度\r\n//          *@Call 回调函数\r\n//          */\r\n//     Animation_Node_Move(Node: Node, Position: Vec3, Speed: number = 520, Call: Function = () => { }) {\r\n//         let Move_Time: number = this.Get_Move_Time(Speed, Node.position, Position);\r\n//         tween(Node)\r\n//             .to(Move_Time, { position: Position })\r\n//             .call(() => {\r\n//                 Call && Call();\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n//     Animation_Num_Move(Node: Node, Position: Vec3, Time: number = 1, Call: Function = () => { }) {\r\n//         tween(Node)\r\n//             .to(Time, { position: Position })\r\n//             .call(() => {\r\n//                 Call && Call();\r\n//             })\r\n//             .start();\r\n//         // tween(Node)\r\n//         //     .to(Time, { scale: v3(0.4, 0.4, 1) })\r\n//         //     .start();\r\n//     }\r\n\r\n//     /**获得移动时间 */\r\n//     Get_Move_Time(Speed: number, Start_Pos: Vec3, Finish_Position: Vec3) {\r\n//         let Dis = this.Get_Distance(Start_Pos, Finish_Position);\r\n//         let Time = Number((Dis / Speed).toFixed(2));\r\n//         return Time;\r\n//     }\r\n\r\n//     /**动画_加载效果 \r\n//     *@mask 遮罩\r\n//     *@Bar 进度条\r\n//     *@Schedule 进度\r\n//     *@Time 时间\r\n//     */\r\n//     Animation_Loading(Mask: Node, Bar: Node, Schedule: Label, Time: number = 1, Call = () => { }) {\r\n//         let width = Bar.getComponent(UITransform).width;\r\n//         Bar.position = v3(width, Bar.position.y, Bar.position.z);\r\n//         Mask.position = v3(-width, Mask.position.y, Mask.position.z);\r\n//         tween(Mask)\r\n//             .to(Time, { position: v3(0, Mask.position.y, Mask.position.z) })\r\n//             .start();\r\n//         tween(Bar)\r\n//             .to(Time, { position: v3(0, Bar.position.y, Bar.position.z) })\r\n//             .start();\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(Time, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     let Value = (100 * ratio).toFixed(0);\r\n//                     Schedule.string = Value + \"%\"\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .call(() => {\r\n//                 Call && Call();\r\n//             })\r\n//             .start();\r\n//     }\r\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n\r\n//     /**深拷贝 */\r\n//     Copy_Obj = (Obj = {}) => {\r\n//         let New_Obj = null;\r\n//         //判断是否需要继续进行递归\r\n//         if (typeof (Obj) == 'object' && Obj !== null) {\r\n//             New_Obj = Obj instanceof Array ? [] : {};//进行下一层递归克隆\r\n//             for (var i in Obj) {\r\n//                 New_Obj[i] = this.Copy_Obj(Obj[i]) //如果不是对象直接赋值\r\n//             }\r\n//         } else {\r\n//             New_Obj = Obj\r\n//         };\r\n//         return New_Obj;\r\n//     }\r\n//     /**深拷贝 */\r\n//     Copy_Deep<T>(Obj: T): T {\r\n//         if (typeof Obj !== 'object' || Obj === null) {\r\n//             return Obj;\r\n//         }\r\n//         if (Array.isArray(Obj)) {\r\n//             return Obj.map(Item => this.Copy_Deep(Item)) as any;\r\n//         }\r\n//         const Copied_Obj: Partial<T> = {};\r\n//         for (const Key in Obj) {\r\n//             if (Object.prototype.hasOwnProperty.call(Obj, Key)) {\r\n//                 Copied_Obj[Key] = this.Copy_Deep(Obj[Key]);\r\n//             }\r\n//         }\r\n//         return Copied_Obj as T;\r\n//     }\r\n//     /**浅拷贝 */\r\n//     Shallow_Copy<T>(Obj: T): T {\r\n//         if (typeof Obj !== 'object' || Obj === null) {\r\n//             return Obj;\r\n//         }\r\n//         if (Array.isArray(Obj)) {\r\n//             return Obj.slice() as any;\r\n//         }\r\n//         const Copied_Obj = { ...Obj };\r\n//         return Copied_Obj;\r\n//     }\r\n\r\n//     /**传入一个网址，浏览器这个网址跳转(相对路径) */\r\n//     Jump_Url(url: string): void {\r\n//         sys.openURL(url);\r\n//     }\r\n\r\n//     /**\r\n//      *\r\n//      *@param Url 网址路径\r\n//      *@param Way 打开方式\r\n//      *@param \"_blank\": 表示在新的标签页中打开链接\r\n//      *@param \"_parent\"：在父级框架中打开链接。\r\n//      *@param \"_top\"：在顶级框架中打开链接。\r\n//      */\r\n//     Open_Url(Url: string, Way?): void {\r\n//         if (this.Get_Type_Is_Abnormal(Way)) {\r\n//             window.open(Url, \"_blank\");\r\n//         } else {\r\n//             window.open(Url, Way);\r\n//         }\r\n//     }\r\n\r\n\r\n\r\n//     /**获取类型是否异常\r\n//      *@true 正常\r\n//      *@false 异常\r\n//      */\r\n//     Get_Type_Is_Abnormal(Value: any): boolean {\r\n//         return Value === null ? false : Value === undefined ? false : true;\r\n//     }\r\n\r\n\r\n\r\n\r\n//     /**获取分割后的精灵数组 */\r\n//     Get_Split_SpriteFrame_Array(spriteFrame: SpriteFrame, rows: number, cols: number): SpriteFrame[] {\r\n//         const spriteFrames: SpriteFrame[] = [];\r\n//         const tex = spriteFrame.texture as Texture2D;\r\n//         const texWidth = tex.width;\r\n//         const texHeight = tex.height;\r\n//         const frameWidth = texWidth / cols;\r\n//         const frameHeight = texHeight / rows;\r\n//         for (let row = 0; row < rows; row++) {\r\n//             for (let col = 0; col < cols; col++) {\r\n//                 const rect = new Rect(col * frameWidth, row * frameHeight, frameWidth, frameHeight);\r\n//                 const newSpriteFrame = new SpriteFrame();\r\n//                 newSpriteFrame.texture = tex;\r\n//                 newSpriteFrame.rect = rect;\r\n//                 spriteFrames.push(newSpriteFrame);\r\n//             }\r\n//         }\r\n//         return spriteFrames;\r\n//     }\r\n\r\n//     /**获取输入类型是否为Number\r\n//      *@用户输入文本时，如果输入的文本只包含数字字符（0-9），则返回 true；如果包含其他字符，则返回 false\r\n//      */\r\n//     Get_Input_Is_Number(String: string) {\r\n//         return /^\\d*$/.test(String);\r\n//     }\r\n\r\n//     /**获取分割后的小数\r\n//      *@integerPart为小数点前的数字，decimalPart为小数点后的数字\r\n//      */\r\n//     Get_split_Decimal(Number: number): [number, number] {\r\n//         const integerPart = Math.floor(Number);\r\n//         const decimalPart = Math.abs(Number - integerPart) * Math.pow(10, Number.toString().split('.')[1].length);\r\n//         return [integerPart, decimalPart];\r\n//     }\r\n\r\n//     //--------------------------------------------------\r\n//     /*数组区*/\r\n\r\n//     /**传入一个数组打乱顺序并返回 */\r\n//     Get_Array_Shuffle<T>(Arr: T[]): T[] {\r\n//         for (let i = Arr.length - 1; i > 0; i--) {\r\n//             const j = Math.floor(Math.random() * (i + 1));\r\n//             [Arr[i], Arr[j]] = [Arr[j], Arr[i]];\r\n//         }\r\n//         return Arr;\r\n//     }\r\n\r\n//     /**\r\n//      *检查节点是否在节点数组中\r\n//      *@param Node_Array 需要检查的节点数组\r\n//      *@param Target_Node 需要查找的目标节点\r\n//      *@returns 如果目标节点在数组中,返回true,否则返回false\r\n//      */\r\n//     Check_Node_In_Array(Target_Node: Node | null | undefined, Node_Array: Node[] | null | undefined): boolean {\r\n//         if (!this.Get_Type_Is_Abnormal(Target_Node) || !this.Get_Type_Is_Abnormal(Node_Array)) {\r\n//             return false;\r\n//         }\r\n//         if (!Node_Array || !Target_Node) {\r\n//             return false;\r\n//         }\r\n//         return Node_Array.some(Node => Node === Target_Node);\r\n//     }\r\n\r\n//     /**获取数组中最小的数字 */\r\n//     Get_Min_Value(Numbers: number[]): number {\r\n//         let Min = Numbers[0];\r\n//         for (let i = 1; i < Numbers.length; i++) {\r\n//             if (Numbers[i] < Min) {\r\n//                 Min = Numbers[i];\r\n//             }\r\n//         }\r\n//         return Min;\r\n//     }\r\n\r\n//     /**传入一个一维数字数组，返回每个数字出现的次数 */\r\n//     Get_Number_Appear_Count_Array(Arr: number[]): { [Key: number]: number } {\r\n//         const occurrences: { [Key: number]: number } = {};\r\n//         for (let i = 0; i < Arr.length; i++) {\r\n//             const num = Arr[i];\r\n//             if (occurrences.hasOwnProperty(num)) {\r\n//                 occurrences[num]++;\r\n//             } else {\r\n//                 occurrences[num] = 1;\r\n//             }\r\n//         }\r\n//         return occurrences;\r\n//     }\r\n\r\n//     /**传入一个数组，返回为空的下标数组 */\r\n//     Get_Null_Index_Array(Arr): Array<any> {\r\n//         let Srr = []\r\n//         for (let i = 0; i < Arr.length; i++) {\r\n//             if (Arr[i] == null) {\r\n//                 Srr.push(i);\r\n//             }\r\n//         }\r\n//         return Srr;\r\n//     }\r\n\r\n//     /**判断数字Number是否存在数组Number[]并返回*/\r\n//     Get_Number_Exist_Array(Number: number, Number_Arr: number[]): boolean {\r\n//         return Number_Arr.indexOf(Number) !== -1;\r\n//     }\r\n\r\n//     /**传入一个数组去重后返回 */\r\n//     Get_Array_Deduplication<T>(Arr: T[]): T[] {\r\n//         return Array.from(new Set(Arr));\r\n//     }\r\n\r\n\r\n\r\n//     /**传入两个数组返回是否相等 */\r\n//     Get_Arrays_Equal(Arr_key: any[], Arr_value: any[]): boolean {\r\n//         // 检查数组长度是否相等\r\n//         if (Arr_key.length !== Arr_value.length) {\r\n//             return false;\r\n//         }\r\n//         // 逐个比较数组元素\r\n//         for (let i = 0; i < Arr_key.length; i++) {\r\n//             if (Arr_key[i] !== Arr_value[i]) {\r\n//                 return false;\r\n//             }\r\n//         }\r\n//         // 所有元素都相等\r\n//         return true;\r\n//     }\r\n\r\n//     /**传入一个布尔数组，如果全部为true返回true,否则返回false */\r\n//     Get_Check_All_True(Boolean_Arr: boolean[]): boolean {\r\n//         return Boolean_Arr.every((value) => value === true);\r\n//     }\r\n\r\n//     /**传入一个布尔数组，如果全部为false返回true,否则返回false */\r\n//     Get_Check_All_False(Boolean_Arr: boolean[]): boolean {\r\n//         return Boolean_Arr.every((value) => value === false);\r\n//     }\r\n\r\n\r\n\r\n//     /**获取数组的子区间\r\n//     *@param Target_Arr 数组\r\n//     *@param Lenth 子区间的长度\r\n//     */\r\n//     Get_Arr_Extracted_Elements<T>(Target_Arr: T[], Lenth: number): T[] | undefined {\r\n//         if (Lenth > Target_Arr.length) {\r\n//             Lenth = Target_Arr.length;\r\n//         }\r\n//         let Target_Arr_ = [...Target_Arr];\r\n//         Target_Arr_ = this.Get_Array_Shuffle(Target_Arr_);\r\n//         //子区间数组\r\n//         const Subinterval_Arr = Array.from(new Set(Target_Arr_)).slice(0, Lenth);\r\n//         return Subinterval_Arr;\r\n//     }\r\n\r\n\r\n//     /**获取概率\r\n//      *@Probability概率\r\n//      */\r\n//     Get_Probability(Probability: number): boolean {\r\n//         let Probability_ = this.Get_Random_Int(0, Math.round((100 - Probability) / Probability));\r\n//         if (Probability_ == 0) {\r\n//             return true;\r\n//         } else {\r\n//             return false;\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//      *获取随机数_双闭区间\r\n//      *@param Min 最小数\r\n//      *@param Max 最大数\r\n//      */\r\n\r\n\r\n\r\n//     /**\r\n//      *位置限制\r\n//      *@param Target_Position 目标坐标\r\n//      *@param Min_Position 最小坐标\r\n//      *@param Max_Position 最大坐标\r\n//      */\r\n//     Position_Restricted(Target_Position: Vec3, Min_Position: Vec3, Max_Position: Vec3, Ortho_Height_Multiple: number) {\r\n//         /**设计分辨率 */\r\n//         let Design_Width = view.getDesignResolutionSize().width / 2 * Ortho_Height_Multiple;\r\n//         let Design_Height = view.getDesignResolutionSize().height / 2 * Ortho_Height_Multiple;\r\n\r\n//         Min_Position = v3(Min_Position.x + Design_Width, Min_Position.y + Design_Height, 0);\r\n//         Max_Position = v3(Max_Position.x - Design_Width, Max_Position.y - Design_Height, 0);\r\n//         if (Target_Position.x < Min_Position.x) {\r\n//             Target_Position = v3(Min_Position.x, Target_Position.y, 0);\r\n//         } else if (Target_Position.x > Max_Position.x) {\r\n//             Target_Position = v3(Max_Position.x, Target_Position.y, 0);\r\n//         }\r\n\r\n//         if (Target_Position.y < Min_Position.y) {\r\n//             Target_Position = v3(Target_Position.x, Min_Position.y, 0);\r\n//         } else if (Target_Position.y > Max_Position.y) {\r\n//             Target_Position = v3(Target_Position.x, Max_Position.y, 0);\r\n//         }\r\n//         return Target_Position;\r\n//     }\r\n\r\n//     /**获取两点角度\r\n//      *@param Start_Position 起点坐标\r\n//      *@param Finish_Positionition 终点坐标\r\n//      */\r\n//     Get_Angle(Start_Position: Vec3, Finish_Positionition: Vec3): number {\r\n//         const Delta_X = Finish_Positionition.x - Start_Position.x;\r\n//         const Delta_Y = Finish_Positionition.y - Start_Position.y;\r\n//         const AngleIn_Degrees = Math.atan2(Delta_Y, Delta_X) * (180 / Math.PI);\r\n//         return AngleIn_Degrees;\r\n//     }\r\n\r\n//     /**获取两点距离\r\n//      *@param Start_Position 起点坐标\r\n//      *@param Finish_Positionition 终点坐标\r\n//      */\r\n//     Get_Distance(Start_Position: Vec3, Finish_Positionition: Vec3) {\r\n//         if (!this.Get_Type_Is_Abnormal(Start_Position) || !this.Get_Type_Is_Abnormal(Finish_Positionition)) {\r\n//             console.warn(\"类型异常\");\r\n//             return;\r\n//         }\r\n//         return Number(Vec2.distance(Start_Position, Finish_Positionition).toFixed(2));\r\n//     }\r\n\r\n//     /**获取一个节点与一群子节点中相距最小的节点的下标和距离\r\n//      *@param Node 节点\r\n//      *@param Target_Node 目标父节点\r\n//      */\r\n//     Get_Min_Distance_Node(Node: Node, Target_Parent_Node: Node): object {\r\n//         if (!this.Get_Type_Is_Abnormal(Node) || !this.Get_Type_Is_Abnormal(Target_Parent_Node)) {\r\n//             console.warn(\"类型异常\");\r\n//             return;\r\n//         }\r\n//         if (Target_Parent_Node.children.length < 1) {\r\n//             return;\r\n//         }\r\n//         let Min_Index = 0;\r\n//         let Min_Distance = 999//this.Get_Distance(Node.getWorldPosition(), Target_Parent_Node.children[0].getWorldPosition());\r\n//         for (let i = 0; i < Target_Parent_Node.children.length; i++) {\r\n//             if (Node.parent === Target_Parent_Node) {\r\n//                 if (Node.getSiblingIndex() === i) {\r\n//                     continue;\r\n//                 }\r\n//             }\r\n//             let Distance = this.Get_Distance(Node.getWorldPosition(), Target_Parent_Node.children[i].getWorldPosition());\r\n//             if (Distance < Min_Distance) {\r\n//                 Min_Distance = Distance;\r\n//                 Min_Index = i;\r\n//             }\r\n//         }\r\n//         return [Min_Index, Min_Distance];\r\n//     }\r\n//     /**获取一个坐标与一群子节点中相距最小的节点的下标和距离\r\n//      *@param Node 节点\r\n//      *@param Target_Node 目标父节点\r\n//      */\r\n//     Get_Min_Distance_Position(Position: Vec3, Target_Parent_Node: Node): object {\r\n//         if (!this.Get_Type_Is_Abnormal(Position) || !this.Get_Type_Is_Abnormal(Target_Parent_Node)) {\r\n//             console.warn(\"类型异常\");\r\n//             return;\r\n//         }\r\n//         if (Target_Parent_Node.children.length < 1) {\r\n//             return;\r\n//         }\r\n//         let Min_Index = 0;\r\n//         let Min_Distance = 999;\r\n//         for (let i = 0; i < Target_Parent_Node.children.length; i++) {\r\n//             let Distance = this.Get_Distance(Position, Target_Parent_Node.children[i].position);\r\n//             // console.log(Distance,Target_Parent_Node.children[i].position,position);\r\n//             if (Distance < Min_Distance) {\r\n//                 Min_Distance = Distance;\r\n//                 Min_Index = i;\r\n//             }\r\n//         }\r\n//         return [Min_Index, Min_Distance];\r\n//     }\r\n\r\n//     /**获取一个角色与一群角色中相距最小的角色的下标和距离\r\n//     *@param Role 角色坐标\r\n//     *@param Target_Role_Arr 目标角色数组\r\n//     */\r\n//     Get_Min_Distance_Role(Role: Node, Target_Role_Arr: Node[]): object {\r\n//         if (!this.Get_Type_Is_Abnormal(Role) || !this.Get_Type_Is_Abnormal(Target_Role_Arr)) {\r\n//             console.warn(\"异常\");\r\n//             return;\r\n//         }\r\n//         if (Target_Role_Arr.length < 1) {\r\n//             return;\r\n//         }\r\n//         let Min_Index = 0;\r\n//         let Min_Distance = 999;\r\n//         for (let i = 0; i < Target_Role_Arr.length; i++) {\r\n//             if (Role == Target_Role_Arr[i]) {\r\n//                 continue;\r\n//             }\r\n//             let Distance = this.Get_Distance(Role.position.clone(), Target_Role_Arr[i].position.clone());\r\n//             if (Distance < Min_Distance) {\r\n//                 Min_Distance = Distance;\r\n//                 Min_Index = i;\r\n//             }\r\n//         }\r\n//         return [Min_Index, Min_Distance];\r\n//     }\r\n\r\n//     Get_Min_Distance_Pos_Arr(Pos: Vec3, Target_Pos_Arr: Vec3[]): object {\r\n//         if (!this.Get_Type_Is_Abnormal(Pos) || !this.Get_Type_Is_Abnormal(Target_Pos_Arr)) {\r\n//             console.warn(\"异常\");\r\n//             return;\r\n//         }\r\n//         if (Target_Pos_Arr.length < 1) {\r\n//             return;\r\n//         }\r\n//         let Min_Index = 0;\r\n//         let Min_Distance = 999;\r\n//         for (let i = 0; i < Target_Pos_Arr.length; i++) {\r\n//             let Distance = this.Get_Distance(Pos, Target_Pos_Arr[i]);\r\n//             if (Distance < Min_Distance) {\r\n//                 Min_Distance = Distance;\r\n//                 Min_Index = i;\r\n//             }\r\n//         }\r\n//         return [Min_Index, Min_Distance];\r\n//     }\r\n\r\n//     Get_All_Positions_Sorted(position: Vec3, Target_Parent_Node: Node): object {\r\n//         if (Target_Parent_Node.children.length < 1) {\r\n//             return;\r\n//         }\r\n//         let Min_Index_0 = 0;\r\n//         let Min_Distance_0 = 999;\r\n\r\n//         let Min_Index_1 = 0;\r\n//         let Min_Distance_1 = 999;\r\n\r\n//         let Min_Index_2 = 0;\r\n//         let Min_Distance_2 = 999;\r\n\r\n//         for (let i = 0; i < Target_Parent_Node.children.length; i++) {\r\n//             let Distance = this.Get_Distance(position, Target_Parent_Node.children[i].position);\r\n//             // console.log(Distance,Target_Parent_Node.children[i].position,position);\r\n//             if (Distance < Min_Distance_0) {\r\n//                 Min_Distance_0 = Distance;\r\n//                 Min_Index_0 = i;\r\n//             } else if (Distance < Min_Distance_1) {\r\n//                 Min_Distance_1 = Distance;\r\n//                 Min_Index_1 = i;\r\n//             } else if (Distance < Min_Distance_2) {\r\n//                 Min_Distance_2 = Distance;\r\n//                 Min_Index_2 = i;\r\n//             }\r\n//         }\r\n//         return [\r\n//             [Min_Index_0, Min_Distance_0],\r\n//             [Min_Index_1, Min_Distance_1],\r\n//             [Min_Index_2, Min_Distance_2]\r\n//         ];\r\n//     }\r\n\r\n\r\n\r\n//     /**获取一个节点的父节点个数\r\n//     *@param Node 节点\r\n//     */\r\n//     Get_Parent_Count(Node: Node): number {\r\n//         let Parent_Count: number = 0;\r\n//         while (Node.parent) {\r\n//             Parent_Count++;\r\n//             Node = Node.parent;\r\n//         }\r\n//         return Parent_Count;\r\n//     }\r\n\r\n//     /**生成一副扑克 */\r\n//     Get_Poker(): object {\r\n//         type Card = [number, number]; // 数组每个元素是两个数字，分别表示花色和点数\r\n//         const deck: Card[] = [];\r\n//         for (let suit = 1; suit <= 5; suit++) {\r\n//             for (let rank = 1; rank <= 13; rank++) {\r\n//                 if (suit !== 5) {\r\n//                     deck.push([suit, rank]); // 添加普通扑克牌\r\n//                 } else {\r\n//                     if (rank <= 2) {\r\n//                         deck.push([suit, rank]); // 添加小王、大王\r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n//         this.Get_Array_Shuffle(deck);\r\n//         return deck;\r\n//     }\r\n\r\n//     /**\r\n//      *\r\n//      *@param 传入一组数据进行排序 \r\n//      *@example\r\n//      *function sortByBalance(a: any[]): any[] {\r\n//             return a.sort((role1, role2) => role2.Role_Balance - role1.Role_Balance);\r\n//         }\r\n//         // 示例用法\r\n//         let a = [\r\n//         {\r\n//             \"Role_Ranking\": 0,\r\n//             \"Role_Avatar\": null,\r\n//             \"Role_Name\": \"\",\r\n//             \"Role_Balance\": 100\r\n//         },\r\n//         {\r\n//             \"Role_Ranking\": 0,\r\n//             \"Role_Avatar\": null,\r\n//             \"Role_Name\": \"\",\r\n//             \"Role_Balance\": 50\r\n//         },\r\n//         {\r\n//             \"Role_Ranking\": 0,\r\n//             \"Role_Avatar\": null,\r\n//             \"Role_Name\": \"\",\r\n//             \"Role_Balance\": 200\r\n//         }\r\n//         ];\r\n//         const sortedArray = sortByBalance(a);\r\n//         console.log(sortedArray); \r\n//     */\r\n//     sort_Ranking_Data(Ranking_Data: any[]): any[] {\r\n//         return Ranking_Data.sort((Data_1, Data_2) => Data_2.Role_Balance - Data_1.Role_Balance);\r\n//     }\r\n\r\n//     // Sort_Ordinate_Data(Node_: Node) {\r\n//     //     if (Node_ instanceof Node) {\r\n//     //         Node_.children.sort((Node_1, Node_2) => Node_1.position.y - Node_2.position.y);\r\n//     //         Node_.children.forEach((child) => this.Sort_Ordinate_Data(child));\r\n//     //     }\r\n//     //     return [...Node_.children];\r\n//     // }\r\n\r\n//     /**排序_纵坐标_数据 */\r\n//     Sort_Ordinate_Data(Node_: Node) {\r\n//         if (Node_ instanceof Node) {\r\n//             Node_.children.sort((Node_1, Node_2) => Node_2.position.y - Node_1.position.y);\r\n//             // for (let i = 0; i < Node_.children.length; i++) {\r\n//             //     this.Sort_Ordinate_Data(Node_.children[i]);\r\n//             // }\r\n//         }\r\n//         return [...Node_.children];\r\n//     }\r\n\r\n//     /**使该节点的显示层覆盖其父节点的其他子节点 */\r\n//     Set_Seat(Node_: Node) {\r\n//         if (Node_.parent) {\r\n//             const Sibling_ = Node_.parent.children;\r\n//             const Index_ = Sibling_.indexOf(Node_);\r\n//             if (Index_ !== -1 && Index_ !== Sibling_.length - 1) {\r\n//                 Node_.setSiblingIndex(Sibling_.length - 1);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     // 判断两个节点是否相交\r\n//     isNodeInNode(nodeA: Node, nodeB: Node): Boolean {\r\n//         // 获取B节点的包围盒\r\n//         let widthB = nodeB.getComponent(UITransform).width;\r\n//         let heighB = nodeB.getComponent(UITransform).height;\r\n//         // 获取A节点的包围盒\r\n//         let widthA = nodeA.getComponent(UITransform).width;\r\n//         let heightA = nodeA.getComponent(UITransform).height;\r\n//         //判断A节点是否处于B包围盒中\r\n//         let rectB = new Rect(nodeB.worldPosition.x, nodeB.worldPosition.y, widthB, heighB);\r\n//         let rectA = new Rect(nodeA.worldPosition.x, nodeA.worldPosition.y, widthA, heightA);\r\n//         return rectB.intersects(rectA);\r\n//     }\r\n\r\n//     /**判断位置是否在指定位置范围 */\r\n//     Is_Specify_Range(Position_Target: Vec3, Position: Vec3, Range: number): Boolean {\r\n//         let Distance = this.Get_Distance(Position_Target, Position);\r\n//         if (Distance <= Range) {\r\n//             return true;\r\n//         } else {\r\n//             return false;\r\n//         }\r\n//     }\r\n\r\n\r\n\r\n//     /**\r\n//      *检查并修正坐标,使其与坐标数组中的点的距离大于等于指定距离\r\n//      *@param Target_Pos 目标坐标\r\n//      *@param Target_Node 目标节点\r\n//      *@param Dis 指定的距离\r\n//      *@returns 修正后的坐标\r\n//      */\r\n//     Check_And_Fix_Position(Target_Pos: Vec3, Target_Node: Node, Dis: number): Vec3 {\r\n//         // 克隆一个新的坐标对象\r\n//         let Target_Pos_ = Target_Pos.clone();\r\n//         let Pos_Arr: Vec3[] = [];\r\n//         for (let i = 0; i < Target_Node.children.length; i++) {\r\n//             Pos_Arr[i] = Target_Node.children[i].position;\r\n//         }\r\n//         // 循环检查坐标数组中的每个坐标\r\n//         for (let i = 0; i < Pos_Arr.length; i++) {\r\n//             const Pos = Pos_Arr[i].clone();\r\n//             // 计算两点之间的距离\r\n//             const Distance = this.Get_Distance(Target_Pos_.clone(), Pos.clone());\r\n//             // 如果距离小于指定距离,则修正坐标\r\n//             if (Distance < Dis) {\r\n//                 // 计算修正后的新坐标\r\n//                 const direction = Target_Pos_.clone().subtract(Pos.clone()).normalize();\r\n//                 Target_Pos_ = Pos.clone().add(direction.multiplyScalar(Dis));\r\n//             }\r\n//         }\r\n//         return Target_Pos_;\r\n//     }\r\n\r\n//     /**\r\n//      *根据两点坐标和距离,计算距离开始位置Dis的坐标\r\n//      *@param p1 起始点坐标\r\n//      *@param p2 目标点坐标\r\n//      *@param dis 距离起始点的距离\r\n//      *@returns 中间位置坐标\r\n//      */\r\n//     Get_Distance_Position(Start_Position: Vec3, Finish_Position: Vec3, Dis: number): Vec3 {\r\n//         // 计算两点之间的距离\r\n//         const Distance = this.Get_Distance(Start_Position.clone(), Finish_Position.clone());\r\n//         // 如果两点之间的距离小于或等于目标距离,则返回目标点坐标\r\n//         if (Distance <= Dis) {\r\n//             return Finish_Position.clone();\r\n//         }\r\n//         // 计算方向向量\r\n//         const Direction = Finish_Position.clone().subtract(Start_Position.clone()).normalize();\r\n//         // 计算中间位置坐标\r\n//         const Intermediate_Position = Start_Position.clone().add(Direction.multiplyScalar(Dis));\r\n//         return Intermediate_Position;\r\n//     }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//     /**动画_节点_避让\r\n//      *@Node 节点\r\n//      *@Position 位置\r\n//      *@Time 时间\r\n//      *@Call 回调函数\r\n//      */\r\n//     Animation_Node_Avoid(Node: Node, Position: Vec3, Time?: number, Call: Function = () => { }) {\r\n\r\n//     }\r\n\r\n\r\n\r\n\r\n\r\n//     /**动画_预制体_展示 */\r\n//     Animation_Prefab_Show(Node: Node, Time: number, Call: Function = () => { }) {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(Time, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     let curScale = Number(ratio.toFixed(2));\r\n//                     Node.scale = v3(curScale, curScale, curScale);\r\n//                     // node.angle = 360 *(1 - Number(ratio.toFixed(2)));\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .call(() => {\r\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\r\n//                     this.scheduleOnce(() => {\r\n//                         Call && Call();\r\n//                     })\r\n//                 }\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n//     /**动画_心跳效果 */\r\n//     Animation_Heartbeat(node: Node) {\r\n//         tween(node).repeatForever(\r\n//             tween()\r\n//                 .to(0.5, { scale: v3(0.8, 0.8, 1) })\r\n//                 .to(0.3, { scale: v3(0.9, 0.9, 1) })\r\n//                 .to(0.45, { scale: v3(0.75, 0.75, 1) })\r\n//                 .to(0.3, { scale: v3(1, 1, 1) })\r\n//         )\r\n//             .start()\r\n//     }\r\n\r\n\r\n//     /**动画_受击效果\r\n//      *@pNode 节点\r\n//      *@Hit_time 受击时间\r\n//      *@Original_Color 初始颜色\r\n//      */\r\n//     Animation_Hit(Node: Node, Hit_time: number, Original_Color: Color, Call: Function = () => { }) {\r\n//         tween(Node.getComponent(Sprite))\r\n//             .to(Hit_time, { color: color(255, 0, 0, 255) })\r\n//             .call(() => {\r\n//                 Node.getComponent(Sprite).color = Original_Color;\r\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\r\n//                     Call && Call();\r\n//                 }\r\n//             })\r\n//             .start()\r\n//     }\r\n\r\n//     /**动画_死亡效果\r\n//      *@Node 节点\r\n//      *@Hit_time 受击时间\r\n//      *@Original_Color 初始颜色\r\n//      */\r\n//     Animation_Die(Node: Node, Hit_time: number, Original_Color: Color, Call: Function = () => { }) {\r\n\r\n//     }\r\n\r\n//     /**动画_消失效果 */\r\n//     Animation_Disappear(node: Node, disappear_time: number, Call: Function = () => { }) {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(disappear_time, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     let curScale = (1 - Number(ratio.toFixed(2)));\r\n//                     node.scale = v3(curScale, curScale, curScale);\r\n//                     // node.angle = 360 *Number(ratio.toFixed(2));\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .call(() => {\r\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\r\n//                     this.scheduleOnce(() => {\r\n//                         Call && Call();\r\n//                     })\r\n//                 }\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n//     /**动画_消失效果_反转 */\r\n//     Animation_Disappear_Reverse(node: Node, disappear_time: number, Call: Function = () => { }) {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(disappear_time, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     let curScale = Number(ratio.toFixed(2));\r\n//                     node.scale = v3(curScale, curScale, curScale);\r\n//                     // node.angle = 360 *(1 - Number(ratio.toFixed(2)));\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .call(() => {\r\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\r\n//                     this.scheduleOnce(() => {\r\n//                         Call && Call();\r\n//                     })\r\n//                 }\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n//     /**动画_闪光效果 */\r\n//     Animation_Flash(Node: Node, Call: Function = () => { }) {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(0.7, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     let color_value = 255 - (100 * (1 - Number(ratio.toFixed(2))));//255 - (100 *Number(ratio.toFixed(2)));\r\n//                     Node.getComponent(Sprite).color = color(color_value, color_value, color_value, color_value);\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .call(() => {\r\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\r\n//                     this.scheduleOnce(() => {\r\n//                         Call && Call();\r\n//                     })\r\n//                 }\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n\r\n\r\n\r\n//     /**动画_颜色_循环 */\r\n//     Animation_Color_repeatedly(Tag) {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(0.7, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     let color_value = 255 - (100 * Number(ratio.toFixed(2)));\r\n//                     this.node.getComponent(Sprite).color = color(color_value, color_value, color_value, 255);\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .tag(Tag)\r\n//             .call(() => {\r\n//                 startObj = { num: 0 };\r\n//                 endObj = { num: 100 };\r\n//                 tween(startObj)\r\n//                     .to(0.7, endObj, {\r\n//                         progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                             let color_value = 255 - (100 * (1 - Number(ratio.toFixed(2))));\r\n//                             this.node.getComponent(Sprite).color = color(color_value, color_value, color_value, 255);\r\n//                             return;\r\n//                         }\r\n//                     })\r\n//                     .tag(Tag)\r\n//                     .call(() => {\r\n//                         this.Animation_Color_repeatedly(Tag);\r\n//                     })\r\n//                     .start();\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n//     /**动画_金币收集\r\n//      *@node 要移动的节点\r\n//      *@node_target 要移动的目标节点\r\n//      *@collect_time 移动的时间\r\n//      *@Call 回调函数\r\n//      *@example\r\n//      *let node_target: Node = find(\"Canvas/Main/Balance\");\r\n//      *let collect_time = Vec2.distance(this.node.position, node_target.position) / 1000;\r\n//      *Tool_Script.instance.Gold_Collect_Animation(this.node, node_target, collect_time, () => {\r\n//      *     find(\"Resoure_Data\").getComponent(Resoure_Data_Script).Balance++;\r\n//      *     find(\"Resoure_Data\").getComponent(Resoure_Data_Script).Re_Balance();\r\n//      *})\r\n//      */\r\n//     Animation_Gold_Collect(node: Node, node_target: Node, collect_time: number, Call: Function = () => { }) {\r\n//         tween(node)\r\n//             .to(collect_time, { position: v3(node_target.position.x, node_target.position.y, 0), scale: v3(0.2, 0.2, 0) })\r\n//             .call(() => {\r\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\r\n//                     this.scheduleOnce(() => {\r\n//                         Call && Call();\r\n//                     })\r\n//                 }\r\n//                 node.destroy();\r\n//             })\r\n//             .start()\r\n//     }\r\n\r\n//     /**\r\n//      *\r\n//      *@param\r\n//      *@example\r\n//      * let startObj = { num: 255 };\r\n//             let endObj = { num: 0 };\r\n//             tween(startObj)\r\n//                 .to(0.7, endObj, {\r\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                         let curScale = (1 - Number(ratio.toFixed(2)));\r\n//                         this.node.scale = v3(curScale, curScale, curScale);\r\n//                         this.node.getComponent(Sprite).color = color(255, 255, 255, Math.floor(255 *(1 - ratio)));\r\n//                         return;\r\n//                     }\r\n//                 })\r\n//                 .start(); \r\n//      */\r\n//     Animation(Node: Node) {\r\n//         let startObj = { num: 0 };\r\n//         let endObj = { num: 100 };\r\n//         tween(startObj)\r\n//             .to(0.7, endObj, {\r\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\r\n//                     let curScale = Number(ratio.toFixed(2));\r\n//                     Node.scale = v3(curScale, curScale, curScale);\r\n//                     Node.angle = curScale;\r\n//                     Node.getComponent(Sprite).color = color(255, 255, 255, Math.floor(255 * ratio));\r\n//                     return;\r\n//                 }\r\n//             })\r\n//             .start();\r\n//     }\r\n\r\n\r\n//     /**获取在线玩家 */\r\n//     Get_Online_Players(Label: Label, OnlinePlayers: number) {\r\n//         let UpDataTime: number = this.Get_Random_Int(0, 10);\r\n//         let Change_Number: number = this.Get_Random_Int(-50, 50);\r\n//         OnlinePlayers += Change_Number;\r\n//         if (OnlinePlayers <= 0) {\r\n//             OnlinePlayers = 0;\r\n//         }\r\n//         Label.string = OnlinePlayers + \"\";\r\n//         this.scheduleOnce(() => {\r\n//             this.Get_Online_Players(Label, OnlinePlayers);\r\n//         }, UpDataTime)\r\n//     }\r\n\r\n//     /**随机生成名字 */\r\n//     Get_Random_Name(): string {\r\n//         const vowels = ['a', 'e', 'i', 'o', 'u'];\r\n//         const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\r\n\r\n//         const nameLength = Math.floor(Math.random() * 8) + 5; // 随机生成名字的长度，范围为 1 到 10\r\n\r\n//         let name = '';\r\n//         let isVowel = Math.random() < 0.5; // 随机选择首字母是元音还是辅音\r\n\r\n//         for (let i = 0; i < nameLength; i++) {\r\n//             if (isVowel) {\r\n//                 name += vowels[Math.floor(Math.random() * vowels.length)];\r\n//             } else {\r\n//                 name += consonants[Math.floor(Math.random() * consonants.length)];\r\n//             }\r\n\r\n//             isVowel = !isVowel; // 每次循环切换元音和辅音\r\n//         }\r\n\r\n//         return name;\r\n//     }\r\n\r\n\r\n//     /**获取数独 */\r\n//     Get_Sudoku(): number[][] {\r\n\r\n//         // 检查同一行是否有相同的数字\r\n//         function checkRow(Arr: number[][], row: number, num: number): boolean {\r\n//             for (let i = 0; i < 9; i++) {\r\n//                 if (Arr[row][i] === num) {\r\n//                     return false;\r\n//                 }\r\n//             }\r\n//             return true;\r\n//         }\r\n//         // 检查同一列是否有相同的数字\r\n//         function checkColumn(Arr: number[][], col: number, num: number): boolean {\r\n//             for (let i = 0; i < 9; i++) {\r\n//                 if (Arr[i][col] === num) {\r\n//                     return false;\r\n//                 }\r\n//             }\r\n//             return true;\r\n//         }\r\n\r\n//         // 检查同一个3x3九宫格是否有相同的数字\r\n//         function checkGrid(Arr: number[][], startRow: number, startCol: number, num: number): boolean {\r\n//             for (let i = startRow; i < startRow + 3; i++) {\r\n//                 for (let j = startCol; j < startCol + 3; j++) {\r\n//                     if (Arr[i][j] === num) {\r\n//                         return false;\r\n//                     }\r\n//                 }\r\n//             }\r\n//             return true;\r\n//         }\r\n//         const Arr: number[][] = [];\r\n//         const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n//         // 随机打乱数字顺序\r\n//         for (let i = nums.length - 1; i > 0; i--) {\r\n//             const j = Math.floor(Math.random() * (i + 1));\r\n//             [nums[i], nums[j]] = [nums[j], nums[i]];\r\n//         }\r\n//         // 初始化二维数组\r\n//         for (let i = 0; i < 9; i++) {\r\n//             Arr[i] = [];\r\n//             for (let j = 0; j < 9; j++) {\r\n//                 Arr[i][j] = nums[(i * 3 + Math.floor(i / 3) + j) % 9];\r\n//             }\r\n//         }\r\n//         // 随机交换行和列\r\n//         for (let i = 0; i < 3; i++) {\r\n//             const r1 = Math.floor(Math.random() * 3) + i * 3;\r\n//             let r2 = r1;\r\n//             while (r2 === r1) {\r\n//                 r2 = Math.floor(Math.random() * 3) + i * 3;\r\n//             }\r\n//             for (let j = 0; j < 9; j++) {\r\n//                 [Arr[r1][j], Arr[r2][j]] = [Arr[r2][j], Arr[r1][j]];\r\n//             }\r\n\r\n//             const c1 = Math.floor(Math.random() * 3) + i * 3;\r\n//             let c2 = c1;\r\n//             while (c2 === c1) {\r\n//                 c2 = Math.floor(Math.random() * 3) + i * 3;\r\n//             }\r\n//             for (let j = 0; j < 9; j++) {\r\n//                 [Arr[j][c1], Arr[j][c2]] = [Arr[j][c2], Arr[j][c1]];\r\n//             }\r\n//         }\r\n//         // 确保每一行、每一列和每一个3x3九宫格都没有相同的数字\r\n//         for (let i = 0; i < 9; i++) {\r\n//             for (let j = 0; j < 9; j++) {\r\n//                 const num = Arr[i][j];\r\n//                 Arr[i][j] = 0; // 先将当前位置的数字设置为0\r\n\r\n//                 // 检查当前位置是否与同行、同列或同九宫格中的其他位置有相同的数字\r\n//                 if (\r\n//                     checkRow(Arr, i, num) &&\r\n//                     checkColumn(Arr, j, num) &&\r\n//                     checkGrid(Arr, i - (i % 3), j - (j % 3), num)\r\n//                 ) {\r\n//                     Arr[i][j] = num; // 如果没有相同的数字，则将当前位置设置为该数字\r\n//                 } else {\r\n//                     j--; // 如果有相同的数字，则重新尝试下一个数字\r\n//                 }\r\n//             }\r\n//         }\r\n//         return Arr;\r\n//     }\r\n\r\n//     //交换两个节点的索引\r\n//     Swap_SiblingIndex(Node_1: Node, Node_2: Node): void {\r\n//         const Index_1 = Node_1.getSiblingIndex();\r\n//         const Index_2 = Node_2.getSiblingIndex();\r\n//         Node_1.setSiblingIndex(Index_1);\r\n//         Node_2.setSiblingIndex(Index_2);\r\n//     }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// }\r\n\r\n// /**暴露函数 */\r\n// function Fun(parameter: number): number {\r\n//     return parameter;\r\n// }\r\n\r\n// export { Fun };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"]}