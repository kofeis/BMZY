{"version":3,"sources":["file:///D:/Tool/Project/MathMatchs/assets/Script/Other/Tool_Script.ts"],"names":[],"mappings":"AAAA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAEA;AACA;AACA;AACA;AAEA","sourcesContent":["// import { _decorator, Component, Node, Vec2, Vec3, tween, v3, Sprite, UITransform, color, Rect, Label, sys, Prefab, SpriteFrame, instantiate, Texture2D, Material, log, Color, view, Animation, sp, Tween, Button, NodeEventType, director, macro, input, Input, Constructor, UIOpacity, __private, AnimationState, assetManager, AudioClip, AudioSource, isValid } from 'cc';\n// const { ccclass, property } = _decorator;\n\n// @ccclass('Tool_Script')\n// export class Tool_Script extends Component {\n\n\n//     public static readonly instance = new Tool_Script();\n\n\n//     /**\n//      * 数据区\n//      * 事件区\n//      * 功能区\n//      * 动画区\n//      * 其他区\n//      */\n\n\n\n//     /**\n//      *@param 数据保存本地\n//      *@Data_Name 待保存数据的名字\n//      *@Data_Name 待保存的数据\n//      */\n//     Set_Data(Data_Name: string, Data) {\n//         sys.localStorage.setItem(Data_Name, JSON.stringify(Data));\n//     }\n//     /**\n//      *@param 读取本地数据\n//      *@Data_Name 待读取数据的名字\n//      */\n//     Get_Data(Data_Name: string) {\n//         let Data = sys.localStorage.getItem(Data_Name);\n//         return JSON.parse(Data);\n//     }\n\n   \n//     /**延时等待 */\n//     Delay_Time(Time: number): Promise<void> {\n//         return new Promise((resolve, reject) => {\n//             this.scheduleOnce(() => {\n//                 resolve();\n//             }, Time);\n//         })\n//     }\n\n//     /**获取组件 */\n//     Get_Component<T extends Component>(Get_Node: Node, Class_Constructor: Constructor<T>): T | null {\n//         if (!Get_Node || !Get_Node.isValid) return null;\n//         let component = Get_Node.getComponent(Class_Constructor);\n//         if (!component)\n//             component = Get_Node.addComponent(Class_Constructor);\n//         return component;\n//     }\n\n//     /**获取Target_Node在Set_Node坐标系下的本地坐标 */\n//     Get_Pos_Local(Set_Node: Node, Target_Node: Node) {\n//         // 获取Target_Node的世界坐标\n//         const Pos_World = Target_Node.getComponent(UITransform).convertToWorldSpaceAR(v3(0, 0, 0));\n//         // 将Set_Node的世界坐标转换为Target_Node的本地坐标\n//         const Pos_Local = Set_Node.parent.getComponent(UITransform).convertToNodeSpaceAR(Pos_World);\n//         return Pos_Local;\n//     }\n\n//     /**\n//      * 设置父节点\n//      * @param Set_Node 设置的节点\n//      * @param Parent_Node 原父节点\n//      * @param Target_Node 新父节点\n//      */\n//     Set_Parent(Set_Node: Node, Parent_Node: Node, Target_Node: Node) {\n//         //设置父节点\n//         Set_Node.parent = Target_Node;\n//         //获取Set_Node世界坐标\n//         const Pos_World = Parent_Node.getComponent(UITransform).convertToWorldSpaceAR(Set_Node.position);\n//         //将世界坐标转换本地坐标\n//         const Pos_Local = Set_Node.parent.getComponent(UITransform).convertToNodeSpaceAR(Pos_World);\n//         console.log(Pos_Local);\n\n//         Set_Node.position = Pos_Local;\n\n//     }\n\n\n//     /**设置坐标一致 */\n//     Set_Pos_Word_Same(Set_Node: Node, Target_Node: Node) {\n//         Set_Node.setWorldPosition(this.Get_Pos_Word(Target_Node));\n//     }\n//     /**设置世界坐标 */\n//     Set_Pos_Word(Set_Pos: Vec3, Target_Node: Node) {\n//         Target_Node.setWorldPosition(Set_Pos);\n//     }\n//     /**获取世界坐标 */\n//     Get_Pos_Word(Target_Node: Node) {\n//         return Target_Node.getWorldPosition(Target_Node.position);\n//     }\n\n//     /**监听触摸开始 */\n//     On_Btn_TOUCH_START(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.TOUCH_START, Call, Node);\n//     }\n//     /**监听触摸结束 */\n//     On_Btn_TOUCH_END(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.TOUCH_END, Call, Node);\n//     }\n//     /**监听触摸取消 */\n//     On_Btn_TOUCH_CANCEL(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.TOUCH_CANCEL, Call, Node);\n//     }\n//     /**监听触摸移动 */\n//     On_Btn_TOUCH_MOVE(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.TOUCH_MOVE, Call, Node);\n//     }\n//     /**监听触摸按住\n//      * @param Set_Node 监听节点\n//      * @param Response_Time 按住时长\n//      * @param Id 缓动Id\n//      * @param Pressing_Call 按住回调\n//      * @param Pressend_Call 松开\n//      */\n//     On_Btn_TOUCH_Pressing(Set_Node: Node, Response_Time: number, Id: number = 100, Pressing_Call: Function = () => { }, Pressend_Call: Function = () => { }) {\n//         Set_Node.on(NodeEventType.TOUCH_START, () => {\n//             let startObj = { num: 0 };\n//             let endObj = { num: 100 };\n//             tween(startObj)\n//                 .to(Response_Time, endObj, {\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\n//                         return ratio;\n//                     }\n//                 })\n//                 .tag(Id)\n//                 .call(() => {\n//                     Pressing_Call && Pressing_Call();\n//                 })\n//                 .start();\n//         }, Set_Node);\n//         Set_Node.on(NodeEventType.TOUCH_END, () => {\n//             this.Stop_Tween_Tag(Id);\n//             Pressend_Call && Pressend_Call();\n//         }, Node);\n//         Set_Node.on(NodeEventType.TOUCH_CANCEL, () => {\n//             this.Stop_Tween_Tag(Id);\n//             Pressend_Call && Pressend_Call();\n//         }, Set_Node);\n//         Set_Node.on(NodeEventType.TOUCH_MOVE, (Event) => {\n\n//             // 获取浏览器窗口可见区域尺寸\n//             // let Screen_Width = window.innerWidth;\n//             // let Screen_Height = window.innerHeight;\n\n//             // let Touch_Pos = v3(Event.getUILocation().x - Screen_Width / 2, Event.getUILocation().y - Screen_Height / 2, Event.getUILocation().z);\n//             // console.log(Touch_Pos);\n\n//             this.Stop_Tween_Tag(Id);\n//             Pressend_Call && Pressend_Call();\n//         }, Node);\n//     }\n//     /**监听触摸双击\n//      * @param Set_Node 监听节点\n//      * @param Touch_Count_All 触摸总次数\n//      * @param Touch_Interval 触摸间隔\n//      * @param Id 缓动Id\n//      * @param Double_On_Call 双击回调\n//      * @param Double_Off_Call 松开回调\n//      */\n//     On_Btn_TOUCH_Double(Set_Node: Node, Touch_Count_All: number, Touch_Interval: number = 0.25, Id: number = 101, Double_On_Call: Function = () => { }, Double_Off_Call: Function = () => { }) {\n\n//         let Touch_Count: number = 0;\n\n//         Set_Node.on(NodeEventType.TOUCH_START, () => {\n//             this.Stop_Tween_Tag(Id);\n//             Touch_Count++;\n//             if (Touch_Count == Touch_Count_All) {\n//                 Touch_Count = 0;\n//                 Double_On_Call && Double_On_Call();\n//             }\n//             let startObj = { num: 0 };\n//             let endObj = { num: 100 };\n//             tween(startObj)\n//                 .to(Touch_Interval, endObj, {\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\n//                         return;\n//                     }\n//                 })\n//                 .tag(Id)\n//                 .call(() => {\n//                     Touch_Count = 0;\n//                 })\n//                 .start();\n//         }, Set_Node);\n//         // Set_Node.on(NodeEventType.TOUCH_END, () => {\n//         //     this.Stop_Tween_Tag(101);\n//         //     Double_Off_Call && Double_Off_Call();\n//         // }, Node);\n//         // Set_Node.on(NodeEventType.TOUCH_CANCEL, () => {\n//         //     this.Stop_Tween_Tag(101);\n//         //     Double_Off_Call && Double_Off_Call();\n//         // }, Set_Node);\n//     }\n//     /**取消触摸监听 */\n//     Off_Btn_TOUCH(Node: Node, Call: Function = () => { }) {\n//         Node.off(NodeEventType.TOUCH_START, Call, Node);\n//         Node.off(NodeEventType.TOUCH_END, Call, Node);\n//         Node.off(NodeEventType.TOUCH_CANCEL, Call, Node);\n//         Node.off(NodeEventType.TOUCH_MOVE, Call, Node);\n//     }\n//     /**取消所有触摸监听 */\n//     Off_Btn_TOUCH_All(Node: Node) {\n//         Node.off(NodeEventType.TOUCH_START);\n//         Node.off(NodeEventType.TOUCH_END);\n//         Node.off(NodeEventType.TOUCH_CANCEL);\n//         Node.off(NodeEventType.TOUCH_MOVE);\n//     }\n\n\n//     /**监听鼠标按下 */\n//     On_Btn_MOUSE_DOWN(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.MOUSE_DOWN, Call, Node);\n//     }\n//     /**监听鼠标松开 */\n//     On_Btn_MOUSE_UP(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.MOUSE_UP, Call, Node);\n//     }\n//     /**监听鼠标移动 */\n//     On_Btn_MOUSE_MOVE(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.MOUSE_MOVE, Call, Node);\n//     }\n//     /**监听鼠标滚动 */\n//     On_Btn_MOUSE_WHEEL(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.MOUSE_WHEEL, Call, Node);\n//     }\n//     /**监听鼠标进入 */\n//     On_Btn_MOUSE_ENTER(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.MOUSE_ENTER, Call, Node);\n//     }\n//     /**监听鼠标移出 */\n//     On_Btn_MOUSE_LEAVE(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.MOUSE_LEAVE, Call, Node);\n//     }\n\n//     /**监听键盘按下 */\n//     On_KEY_DOWN(Call: Function = () => { }) {\n//         input.on(Input.EventType.KEY_DOWN, Call(), this);\n//     }\n//     /**监听键盘按住 */\n//     On_KEY_PRESSING(Call: Function = () => { }) {\n//         input.on(Input.EventType.KEY_PRESSING, Call(), this);\n//     }\n//     /**监听键盘松开 */\n//     On_KEY_UP(Call: Function = () => { }) {\n//         input.on(Input.EventType.KEY_UP, Call(), this);\n//     }\n\n//     /**监听重力感应 */\n//     On_Sys_DEVICEMOTION(Node: Node, Call: Function = () => { }) {\n//         Node.on(Input.EventType.DEVICEMOTION, Call, Node);\n//     }\n\n//     /**设置按钮事件\n//      * @Set_Node 待设置的节点\n//      * @Target_Node 目标节点\n//      * @Component 脚本/组件名\n//      * @Handler  响应事件函数名\n//      */\n//     Set_Btn_Event_Add(Set_Node: Node, Target_Node: Node, Scr_Name: string, Fun_Name: string, CustomEventData = null) {\n//         let Btn = Set_Node.getComponent(Button);\n//         if (!this.Get_Type_Is_Abnormal(Btn)) {\n//             Btn = Set_Node.addComponent(Button);\n//         }\n//         let Opacity = Set_Node.getComponent(UIOpacity);\n//         if (!this.Get_Type_Is_Abnormal(Opacity)) {\n//             Set_Node.addComponent(UIOpacity);\n//         }\n\n//         let Event = new Component.EventHandler();\n//         Event.target = Target_Node;\n//         Event.component = Scr_Name;\n//         Event.handler = Fun_Name;\n//         Event.customEventData = CustomEventData;\n//         Btn.clickEvents.push(Event);\n//         console.info(Btn.clickEvents);\n//     }\n//     /**设置按钮动画\n//      * @Anim_Switch 动画开关 \n//      */\n//     Set_Btn_Event_Anim(Set_Node: Node, Anim_Switch: boolean = false) {\n//         let Btn = Set_Node.getComponent(Button);\n//         if (!this.Get_Type_Is_Abnormal(Btn)) {\n//             Btn = Set_Node.addComponent(Button);\n//         }\n//         let Opacity = Set_Node.getComponent(UIOpacity);\n//         if (!this.Get_Type_Is_Abnormal(Opacity)) {\n//             Set_Node.addComponent(UIOpacity);\n//         }\n\n//         if (Anim_Switch) {\n//             this.Off_Btn_TOUCH(Set_Node);\n//             Btn.transition = 0;\n//             let Anim_State = false;\n//             Set_Node.off(NodeEventType.TOUCH_START, () => {\n//                 if (Anim_State) {\n//                     return;\n//                 }\n//                 Anim_State = true;\n//                 Anim_On(Set_Node);\n//             }, Set_Node);\n//             this.On_Btn_TOUCH_START(Set_Node, () => {\n//                 if (Anim_State) {\n//                     return;\n//                 }\n//                 Anim_State = true;\n//                 Anim_On(Set_Node);\n//             })\n//             this.On_Btn_TOUCH_END(Set_Node, () => {\n//                 if (!Anim_State) {\n//                     return;\n//                 }\n//                 Anim_State = false;\n//                 Anim_Off(Set_Node);\n//             })\n//             this.On_Btn_TOUCH_CANCEL(Set_Node, () => {\n//                 if (!Anim_State) {\n//                     return;\n//                 }\n//                 Anim_State = false;\n//                 Anim_Off(Set_Node);\n//             })\n//             this.On_Btn_TOUCH_MOVE(Set_Node, (Event) => {\n//                 // console.log(Event.getUILocation());\n//                 // console.log(Event);\n//                 let Target_Width = Event.target.getComponent(UITransform).width;\n//                 let Target_Height = Event.target.getComponent(UITransform).height;\n//                 let Touch_Pos_World = v3(Event.getUILocation().x, Event.getUILocation().y, Event.getUILocation().z);\n//                 let Target_Pos_World = Event.target.getWorldPosition();\n//                 if (Touch_Pos_World.x < Target_Pos_World.x - Target_Width / 2 || Touch_Pos_World.x > Target_Pos_World.x + Target_Width / 2 || Touch_Pos_World.y < Target_Pos_World.y - Target_Height / 2 || Touch_Pos_World.y > Target_Pos_World.y + Target_Height / 2) {\n//                     if (!Anim_State) {\n//                         return;\n//                     }\n//                     Anim_State = false;\n//                     Anim_Off(Set_Node);\n//                 } else {\n//                     if (Anim_State) {\n//                         return;\n//                     }\n//                     Anim_State = true;\n//                     Anim_On(Set_Node);\n//                 }\n//             })\n//         } else {\n//             Btn.transition = 3;\n//             Btn.zoomScale = 0.975;\n//             Btn.duration = 0.05;\n//         }\n//         // function Anim_On(Set_Node) {\n//         //     console.log(\"按下\");\n//         //     let Time = 0.25;\n//         //     tween(Set_Node)\n//         //         .to(Time, { scale: v3(0.8, 0.8, 1) })\n//         //         .start();\n//         //     tween(Set_Node.getComponent(UIOpacity))\n//         //         .to(Time, { opacity: 100 })\n//         //         .start();\n//         // }\n\n//         // function Anim_Off(Set_Node) {\n//         //     console.log(\"松开\");\n//         //     tween(Set_Node)\n//         //         .to(0.17, { scale: v3(1.05, 1.05, 1) })\n//         //         .to(0.08, { scale: v3(1, 1, 1) })\n//         //         .start();\n//         //     tween(Set_Node.getComponent(UIOpacity))\n//         //         .to(0.25, { opacity: 255 })\n//         //         .start();\n//         // }\n//         function Anim_On(Set_Node) {\n//             console.log(\"按下\");\n//             let Time = 0.15;\n//             tween(Set_Node)\n//                 .to(Time, { scale: v3(0.95, 0.95, 1) })\n//                 .start();\n//             tween(Set_Node.getComponent(UIOpacity))\n//                 .to(Time, { opacity: 200 })\n//                 .start();\n//         }\n\n//         function Anim_Off(Set_Node) {\n//             console.log(\"松开\");\n//             tween(Set_Node)\n//                 .to(0.1, { scale: v3(1.05, 1.05, 1) })\n//                 .to(0.05, { scale: v3(1, 1, 1) })\n//                 .start();\n//             tween(Set_Node.getComponent(UIOpacity))\n//                 .to(0.15, { opacity: 255 })\n//                 .start();\n//         }\n//     }\n\n\n//     /**重置按钮组件 */\n//     Set_Btn_Event_Reset(Node: Node) {\n//         let Btn = Node.getComponent(Button);\n//         if (!this.Get_Type_Is_Abnormal(Btn)) { return }\n//         Btn.resetInEditor();\n//     }\n\n//     // /**注册场景监听 */\n//     // On_Screen() {\n//     //     const CurrentScene = director.getScene();\n//     //     CurrentScene.on('window-resize', this.On_Window_Resize, this);\n//     //     CurrentScene.on('orientation-change', this.On_Orientation_Change, this);\n//     //     CurrentScene.on('fullscreen-change', this.On_Full_ScreenChange, this);\n//     // }\n//     // /**注销场景监听 */\n//     // Off_Screen() {\n//     //     const CurrentScene = director.getScene();\n//     //     CurrentScene.off('window-resize', this.On_Window_Resize, this);\n//     //     CurrentScene.off('orientation-change', this.On_Orientation_Change, this);\n//     //     CurrentScene.off('fullscreen-change', this.On_Full_ScreenChange, this);\n//     // }\n\n//     // /**监听窗口大小变化\n//     //  * @p 支持平台:网页、原生、小游戏\n//     //  */\n//     // On_Window_Resize(Width: number, Height: number) {\n//     //     console.log(\"Window resized:\");\n//     //     console.log(\"Width\", Width);\n//     //     console.log(\"Height\", Height);\n//     // }\n//     // /**监听屏幕方向变化\n//     //  * @p 支持平台:网页、原生\n//     //  */\n//     // On_Orientation_Change(orientation: number) {\n//     //     if (orientation === macro.ORIENTATION_LANDSCAPE_LEFT || orientation === macro.ORIENTATION_LANDSCAPE_RIGHT) {\n//     //         console.log(\"Orientation changed to landscape:\", orientation);//横屏\n//     //     } else {\n//     //         console.log(\"Orientation changed to portrait:\", orientation);//竖屏\n//     //     }\n//     // }\n//     /**监听全屏变化\n//      * @p 支持平台:网页\n//      */\n//     On_Full_ScreenChange(Width: number, Height: number) {\n//         console.log(\"Fullscreen change:\");\n//         console.log(\"Width\", Width);\n//         console.log(\"Height\", Height);\n//     }\n\n//     /**监听激活状态 */\n//     On_Node_Active_State(Node: Node, Call: Function = () => { }) {\n//         Node.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, Call, Node);\n//     }\n\n\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n//     /**获取闭区间[Min,Max]内的随机数*/\n//     Get_Random_Int(Min: number, Max: number): number {\n//         Min = Math.ceil(Min);\n//         Max = Math.floor(Max);\n//         return Math.floor(Math.random() * (Max - Min + 1)) + Min;\n//     }\n\n//     /** 获取闭区间 [Min, Max] 内的数组 Arr 外的随机数，如果不存在返回 -1；\n//      * @param Min 最小数\n//      * @param Max 最大数\n//      * @param Arr 数组\n//      * @example Get_Random_Int_Plus(0, 6, [1, 2, 3, 4]); // return 0/5/6\n//      */\n//     Get_Random_Int_Plus(Min: number, Max: number, Arr: number[]): number {\n//         // 将数组 Arr 转换为 Set，以便快速查找\n//         const excludedNumbers = new Set(Arr);\n//         const availableNumbers: number[] = [];\n\n//         // 收集可用的数字\n//         for (let i = Min; i <= Max; i++) {\n//             if (!excludedNumbers.has(i)) {\n//                 availableNumbers.push(i);\n//             }\n//         }\n\n//         // 如果没有可用的数字，返回 -1\n//         if (availableNumbers.length === 0) {\n//             return -1;\n//         } else {\n//             // 获取随机索引并返回对应的随机数\n//             const randomIndex = this.Get_Random_Int(0, availableNumbers.length - 1);\n//             return availableNumbers[randomIndex];\n//         }\n//     }\n\n//     /**\n//      *获取一组不重复的数据\n//      *@param Min 最小数\n//      *@param Max 最大数\n//      *@param Lenth 数组长度\n//      */\n//     Get_Random_Number_Array(Min: number, Max: number, Length: number): number[] {\n//         // 确保 Length 不超过可用范围\n//         Length = Math.min(Length, (Max - Min) + 1);\n//         const result: Set<number> = new Set(); // 使用 Set 来避免重复\n//         while (result.size < Length) {\n//             const randomNum = this.Get_Random_Int(Min, Max);\n//             result.add(randomNum); // Set 会自动处理重复\n//         }\n//         return Array.from(result); // 将 Set 转换为数组\n//     }\n\n\n//     /**\n//      *@param 获取一个预制体\n//      *@param Prefab 预制体\n//      *@param Parent_Node 父节点\n//      *@param Position 坐标\n//      *@param SpriteFrame 精灵框架\n//      *@param Call 回调\n//      *@returns 返回此预制体\n//      */\n//     Get_Prefab_Plus(Prefab: Prefab, Parent_Node: Node, Position: Vec3, SpriteFrame: SpriteFrame, Call: Function = () => { }) {\n//         let Node: Node = instantiate(Prefab);\n//         Node.parent = Parent_Node;\n//         if (SpriteFrame != null) {\n//             Node.getComponent(Sprite).spriteFrame = SpriteFrame;\n//         }\n//         Node.setPosition(Position);\n//         Call && Call();\n//         return Node;\n//     }\n\n\n//     //时间--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n//     /**秒数转时间字符串 */\n//     Seconds_To_Time_String(Seconds: number): string {\n//         const Hours = Math.floor(Seconds / 3600);\n//         const Minutes = Math.floor((Seconds % 3600) / 60);\n//         const Secs = Seconds % 60;\n//         // 手动格式化为两位数\n//         let FormattedHours = (Hours < 10 ? '0' : '') + Hours + \":\";\n//         if (Hours == 0) {\n//             FormattedHours = \"\";\n//         }\n//         let FormattedMinutes = (Minutes < 10 ? '0' : '') + Minutes + \":\";\n//         let FormattedSeconds = (Secs < 10 ? '0' : '') + Secs;\n//         return `${FormattedHours}${FormattedMinutes}${FormattedSeconds}`;\n//     }\n\n\n\n\n\n\n\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n//     /**替换字符串中的所有字符\n//      *@将Str0中的Str1替换为Str2\n//      */\n//     Replace_All_Chars_InString(Str0: string, Str1: string, Str2: string): string {\n//         return Str0.replace(new RegExp(Str1, 'g'), Str2);\n//     }\n\n\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n//     //动画区\n\n//     /**播放帧动画\n//      * @param Name 动画名字\n//      * @param Min_Range 播放范围\n//      * @param Max_Range 播放范围\n//      * @param Speed 播放速率\n//      * @param WrapMode 循环方式\n//      * @param RepeatCount 重复次数\n//      * @param Delay 延时时间\n//      * @param Call 回调\n//      */\n//     Anim_Frame_Play(Anim: Animation, Name: string = null, Speed: number = 1, Min_Range: number = null, Max_Range: number = null, WrapMode: __private._cocos_animation_types__WrapMode = null, RepeatCount: number = null, Delay: number = 0, Call: Function = () => { }) {\n//         if (Name == null) {\n//             if (Anim.defaultClip) {\n//                 Name = Anim.defaultClip.name;\n//             } else {\n//                 console.error(\"动画缺失\");\n//                 return;\n//             }\n//         }\n//         let State: AnimationState = Anim.getState(Name);\n//         if (WrapMode != null) {\n//             State.wrapMode = WrapMode;\n//         }\n//         if (RepeatCount != null) {\n//             State.repeatCount = RepeatCount;\n//         }\n//         if (Min_Range != null && Max_Range != null && Min_Range <= Max_Range) {\n//             State.playbackRange = {\n//                 min: Min_Range,\n//                 max: Max_Range\n//             }\n//         }\n//         State.delay = Delay;\n//         State.speed = Speed;\n\n//         Anim.play(Name);\n//         Anim.once(Animation.EventType.FINISHED, () => {\n//             Call && Call();\n//             // Anim.off(Animation.EventType.FINISHED);\n//         });\n//     }\n//     /**切换帧动画 */\n//     Anim_Frame_CrossFade(Anim: Animation, Name: string = null, Duration: number = 0, Call: Function = () => { }) {\n//         Anim.crossFade(Name, Duration);\n//         Anim.once(Animation.EventType.FINISHED, () => {\n//             Call && Call();\n//         });\n//     }\n//     /**恢复帧动画 */\n//     Anim_Frame_Resume(Anim: Animation, Name: string = null, Speed: number = 1, Min_Range: number = null, Max_Range: number = null, WrapMode: __private._cocos_animation_types__WrapMode = null, RepeatCount: number = null, Delay: number = 0, Call: Function = () => { }) {\n//         if (Name == null) {\n//             if (Anim.defaultClip) {\n//                 Name = Anim.defaultClip.name;\n//             } else {\n//                 console.error(\"动画缺失\");\n//                 return;\n//             }\n//         }\n//         let State: AnimationState = Anim.getState(Name);\n//         // console.log(\"是否已被暂停或停止:\", State.isMotionless);\n//         // console.log(\"是否已被暂停:\", State.isPaused);\n//         // console.log(\" 是否正在播放状态\", State.isPlaying);\n//         if (WrapMode != null) {\n//             State.wrapMode = WrapMode;\n\n//         }\n//         if (RepeatCount != null) {\n//             State.repeatCount = RepeatCount;\n//         }\n//         if (Min_Range != null && Max_Range != null && Min_Range <= Max_Range) {\n//             State.playbackRange = {\n//                 min: Min_Range,\n//                 max: Max_Range\n//             }\n//         }\n//         State.delay = Delay;\n//         State.speed = Speed;\n//         if (State.isPlaying) {\n//             if (State.isPaused) {\n//                 Anim.resume();\n//                 Anim.once(Animation.EventType.FINISHED, () => {\n//                     Call && Call();\n//                 });\n//             } else {\n//                 this.Anim_Frame_Pause(Anim);\n//             }\n//         } else {\n//             this.Anim_Frame_Play(Anim, Name, Speed, Min_Range, Max_Range, WrapMode, RepeatCount, Delay, Call);\n//         }\n//     }\n//     /**暂停帧动画 */\n//     Anim_Frame_Pause(Anim: Animation, Call: Function = () => { }) {\n//         Anim.pause();\n//         Anim.off(Animation.EventType.FINISHED);\n//         Call && Call();\n//     }\n//     /**停止帧动画 */\n//     Anim_Frame_Stop(Anim: Animation, Call: Function = () => { }) {\n//         Anim.stop();\n//         Anim.off(Animation.EventType.FINISHED);\n//         Call && Call();\n//     }\n\n\n//     /**播放骨骼动画 */\n//     Anim_Skeleton_Play(Skeleton: sp.Skeleton, Skin: string, Track_Index: number, Anim_Name: string, Loop: boolean, Call: Function = () => { }) {\n//         if (Skin == \"\") {\n//             Skin = \"default\"\n//         }\n//         Skeleton.setSkin(Skin);\n//         //@ts-ignore\n//         Skeleton._updateSkeletonData();\n//         Skeleton.setAnimation(Track_Index, Anim_Name, Loop);\n//         Skeleton.setCompleteListener(() => {\n//             Skeleton.setCompleteListener(null);\n//             Call && Call();\n//         })\n//     }\n\n//     /**溶解动画 */\n//     async Anim_Dissolve(Set_Node: Node, Time: number = 1, Call: Function = () => { }) {\n//         this.Bundles = await this.Load_Bundle(\"Load\");\n//         let Set_Material = await this.Load_Material(\"Effect/dissolve\");\n//         return new Promise<void>(res => {\n//             const Sp = Set_Node.getComponent(Sprite);\n//             if (!Sp.customMaterial) Sp.customMaterial = Set_Material;\n//             Sp.customMaterial.copy(Set_Material);\n//             Sp.customMaterial.setProperty('dissolveThreshold', 0);\n//             let startObj = { num: 0 };\n//             let endObj = { num: 100 };\n//             tween(startObj)\n//                 .to(Time, endObj, {\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\n//                         const Current_Num = 1 * ratio;//0.3 + 0.7\n//                         Sp.customMaterial.setProperty('dissolveThreshold', Current_Num);\n//                         return Current_Num;\n//                     }\n//                 })\n//                 .call(() => {\n//                     res();\n//                     Call && Call();\n//                 })\n//                 .start();\n\n\n//         })\n//     }\n\n\n//     /**停止缓动标签 */\n//     Stop_Tween_Tag(Id: number, Call = () => { }) {\n//         Tween.stopAllByTag(Id);\n//         Call && Call();\n//     }\n\n//     Delay_Schedule(Delay: number, Id: number, Call = () => { }): void {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(Delay, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     return ratio;\n//                 }\n//             })\n//             .tag(Id)\n//             .call(() => {\n//                 Call && Call();\n//             })\n//             .start();\n//     }\n\n//     /**数字跳动 */\n//     Num_Jump(Label: Label, Value: number, Time: number, Id: number, Call = () => { }) {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         Value = Value / 100;\n//         tween(startObj)\n//             .to(Time, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     Label.string = (Number(ratio) * Value).toFixed(2);\n//                     return;\n//                 }\n//             })\n//             .tag(Id)\n//             .call(() => {\n//                 Call && Call();\n//             })\n//             .start();\n//     }\n\n\n//     /**动画_节点_移动\n//          *@Node 节点\n//          *@Position 位置\n//          *@Time 速度\n//          *@Call 回调函数\n//          */\n//     Animation_Node_Move(Node: Node, Position: Vec3, Speed: number = 520, Call: Function = () => { }) {\n//         let Move_Time: number = this.Get_Move_Time(Speed, Node.position, Position);\n//         tween(Node)\n//             .to(Move_Time, { position: Position })\n//             .call(() => {\n//                 Call && Call();\n//             })\n//             .start();\n//     }\n\n//     Animation_Num_Move(Node: Node, Position: Vec3, Time: number = 1, Call: Function = () => { }) {\n//         tween(Node)\n//             .to(Time, { position: Position })\n//             .call(() => {\n//                 Call && Call();\n//             })\n//             .start();\n//         // tween(Node)\n//         //     .to(Time, { scale: v3(0.4, 0.4, 1) })\n//         //     .start();\n//     }\n\n//     /**获得移动时间 */\n//     Get_Move_Time(Speed: number, Start_Pos: Vec3, Finish_Position: Vec3) {\n//         let Dis = this.Get_Distance(Start_Pos, Finish_Position);\n//         let Time = Number((Dis / Speed).toFixed(2));\n//         return Time;\n//     }\n\n//     /**动画_加载效果 \n//     *@mask 遮罩\n//     *@Bar 进度条\n//     *@Schedule 进度\n//     *@Time 时间\n//     */\n//     Animation_Loading(Mask: Node, Bar: Node, Schedule: Label, Time: number = 1, Call = () => { }) {\n//         let width = Bar.getComponent(UITransform).width;\n//         Bar.position = v3(width, Bar.position.y, Bar.position.z);\n//         Mask.position = v3(-width, Mask.position.y, Mask.position.z);\n//         tween(Mask)\n//             .to(Time, { position: v3(0, Mask.position.y, Mask.position.z) })\n//             .start();\n//         tween(Bar)\n//             .to(Time, { position: v3(0, Bar.position.y, Bar.position.z) })\n//             .start();\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(Time, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     let Value = (100 * ratio).toFixed(0);\n//                     Schedule.string = Value + \"%\"\n//                     return;\n//                 }\n//             })\n//             .call(() => {\n//                 Call && Call();\n//             })\n//             .start();\n//     }\n//     //--------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n\n\n\n//     /**深拷贝 */\n//     Copy_Obj = (Obj = {}) => {\n//         let New_Obj = null;\n//         //判断是否需要继续进行递归\n//         if (typeof (Obj) == 'object' && Obj !== null) {\n//             New_Obj = Obj instanceof Array ? [] : {};//进行下一层递归克隆\n//             for (var i in Obj) {\n//                 New_Obj[i] = this.Copy_Obj(Obj[i]) //如果不是对象直接赋值\n//             }\n//         } else {\n//             New_Obj = Obj\n//         };\n//         return New_Obj;\n//     }\n//     /**深拷贝 */\n//     Copy_Deep<T>(Obj: T): T {\n//         if (typeof Obj !== 'object' || Obj === null) {\n//             return Obj;\n//         }\n//         if (Array.isArray(Obj)) {\n//             return Obj.map(Item => this.Copy_Deep(Item)) as any;\n//         }\n//         const Copied_Obj: Partial<T> = {};\n//         for (const Key in Obj) {\n//             if (Object.prototype.hasOwnProperty.call(Obj, Key)) {\n//                 Copied_Obj[Key] = this.Copy_Deep(Obj[Key]);\n//             }\n//         }\n//         return Copied_Obj as T;\n//     }\n//     /**浅拷贝 */\n//     Shallow_Copy<T>(Obj: T): T {\n//         if (typeof Obj !== 'object' || Obj === null) {\n//             return Obj;\n//         }\n//         if (Array.isArray(Obj)) {\n//             return Obj.slice() as any;\n//         }\n//         const Copied_Obj = { ...Obj };\n//         return Copied_Obj;\n//     }\n\n//     /**传入一个网址，浏览器这个网址跳转(相对路径) */\n//     Jump_Url(url: string): void {\n//         sys.openURL(url);\n//     }\n\n//     /**\n//      *\n//      *@param Url 网址路径\n//      *@param Way 打开方式\n//      *@param \"_blank\": 表示在新的标签页中打开链接\n//      *@param \"_parent\"：在父级框架中打开链接。\n//      *@param \"_top\"：在顶级框架中打开链接。\n//      */\n//     Open_Url(Url: string, Way?): void {\n//         if (this.Get_Type_Is_Abnormal(Way)) {\n//             window.open(Url, \"_blank\");\n//         } else {\n//             window.open(Url, Way);\n//         }\n//     }\n\n\n\n//     /**获取类型是否异常\n//      *@true 正常\n//      *@false 异常\n//      */\n//     Get_Type_Is_Abnormal(Value: any): boolean {\n//         return Value === null ? false : Value === undefined ? false : true;\n//     }\n\n\n\n\n//     /**获取分割后的精灵数组 */\n//     Get_Split_SpriteFrame_Array(spriteFrame: SpriteFrame, rows: number, cols: number): SpriteFrame[] {\n//         const spriteFrames: SpriteFrame[] = [];\n//         const tex = spriteFrame.texture as Texture2D;\n//         const texWidth = tex.width;\n//         const texHeight = tex.height;\n//         const frameWidth = texWidth / cols;\n//         const frameHeight = texHeight / rows;\n//         for (let row = 0; row < rows; row++) {\n//             for (let col = 0; col < cols; col++) {\n//                 const rect = new Rect(col * frameWidth, row * frameHeight, frameWidth, frameHeight);\n//                 const newSpriteFrame = new SpriteFrame();\n//                 newSpriteFrame.texture = tex;\n//                 newSpriteFrame.rect = rect;\n//                 spriteFrames.push(newSpriteFrame);\n//             }\n//         }\n//         return spriteFrames;\n//     }\n\n//     /**获取输入类型是否为Number\n//      *@用户输入文本时，如果输入的文本只包含数字字符（0-9），则返回 true；如果包含其他字符，则返回 false\n//      */\n//     Get_Input_Is_Number(String: string) {\n//         return /^\\d*$/.test(String);\n//     }\n\n//     /**获取分割后的小数\n//      *@integerPart为小数点前的数字，decimalPart为小数点后的数字\n//      */\n//     Get_split_Decimal(Number: number): [number, number] {\n//         const integerPart = Math.floor(Number);\n//         const decimalPart = Math.abs(Number - integerPart) * Math.pow(10, Number.toString().split('.')[1].length);\n//         return [integerPart, decimalPart];\n//     }\n\n//     //--------------------------------------------------\n//     /*数组区*/\n\n//     /**传入一个数组打乱顺序并返回 */\n//     Get_Array_Shuffle<T>(Arr: T[]): T[] {\n//         for (let i = Arr.length - 1; i > 0; i--) {\n//             const j = Math.floor(Math.random() * (i + 1));\n//             [Arr[i], Arr[j]] = [Arr[j], Arr[i]];\n//         }\n//         return Arr;\n//     }\n\n//     /**\n//      *检查节点是否在节点数组中\n//      *@param Node_Array 需要检查的节点数组\n//      *@param Target_Node 需要查找的目标节点\n//      *@returns 如果目标节点在数组中,返回true,否则返回false\n//      */\n//     Check_Node_In_Array(Target_Node: Node | null | undefined, Node_Array: Node[] | null | undefined): boolean {\n//         if (!this.Get_Type_Is_Abnormal(Target_Node) || !this.Get_Type_Is_Abnormal(Node_Array)) {\n//             return false;\n//         }\n//         if (!Node_Array || !Target_Node) {\n//             return false;\n//         }\n//         return Node_Array.some(Node => Node === Target_Node);\n//     }\n\n//     /**获取数组中最小的数字 */\n//     Get_Min_Value(Numbers: number[]): number {\n//         let Min = Numbers[0];\n//         for (let i = 1; i < Numbers.length; i++) {\n//             if (Numbers[i] < Min) {\n//                 Min = Numbers[i];\n//             }\n//         }\n//         return Min;\n//     }\n\n//     /**传入一个一维数字数组，返回每个数字出现的次数 */\n//     Get_Number_Appear_Count_Array(Arr: number[]): { [Key: number]: number } {\n//         const occurrences: { [Key: number]: number } = {};\n//         for (let i = 0; i < Arr.length; i++) {\n//             const num = Arr[i];\n//             if (occurrences.hasOwnProperty(num)) {\n//                 occurrences[num]++;\n//             } else {\n//                 occurrences[num] = 1;\n//             }\n//         }\n//         return occurrences;\n//     }\n\n//     /**传入一个数组，返回为空的下标数组 */\n//     Get_Null_Index_Array(Arr): Array<any> {\n//         let Srr = []\n//         for (let i = 0; i < Arr.length; i++) {\n//             if (Arr[i] == null) {\n//                 Srr.push(i);\n//             }\n//         }\n//         return Srr;\n//     }\n\n//     /**判断数字Number是否存在数组Number[]并返回*/\n//     Get_Number_Exist_Array(Number: number, Number_Arr: number[]): boolean {\n//         return Number_Arr.indexOf(Number) !== -1;\n//     }\n\n//     /**传入一个数组去重后返回 */\n//     Get_Array_Deduplication<T>(Arr: T[]): T[] {\n//         return Array.from(new Set(Arr));\n//     }\n\n\n\n//     /**传入两个数组返回是否相等 */\n//     Get_Arrays_Equal(Arr_key: any[], Arr_value: any[]): boolean {\n//         // 检查数组长度是否相等\n//         if (Arr_key.length !== Arr_value.length) {\n//             return false;\n//         }\n//         // 逐个比较数组元素\n//         for (let i = 0; i < Arr_key.length; i++) {\n//             if (Arr_key[i] !== Arr_value[i]) {\n//                 return false;\n//             }\n//         }\n//         // 所有元素都相等\n//         return true;\n//     }\n\n//     /**传入一个布尔数组，如果全部为true返回true,否则返回false */\n//     Get_Check_All_True(Boolean_Arr: boolean[]): boolean {\n//         return Boolean_Arr.every((value) => value === true);\n//     }\n\n//     /**传入一个布尔数组，如果全部为false返回true,否则返回false */\n//     Get_Check_All_False(Boolean_Arr: boolean[]): boolean {\n//         return Boolean_Arr.every((value) => value === false);\n//     }\n\n\n\n//     /**获取数组的子区间\n//     *@param Target_Arr 数组\n//     *@param Lenth 子区间的长度\n//     */\n//     Get_Arr_Extracted_Elements<T>(Target_Arr: T[], Lenth: number): T[] | undefined {\n//         if (Lenth > Target_Arr.length) {\n//             Lenth = Target_Arr.length;\n//         }\n//         let Target_Arr_ = [...Target_Arr];\n//         Target_Arr_ = this.Get_Array_Shuffle(Target_Arr_);\n//         //子区间数组\n//         const Subinterval_Arr = Array.from(new Set(Target_Arr_)).slice(0, Lenth);\n//         return Subinterval_Arr;\n//     }\n\n\n//     /**获取概率\n//      *@Probability概率\n//      */\n//     Get_Probability(Probability: number): boolean {\n//         let Probability_ = this.Get_Random_Int(0, Math.round((100 - Probability) / Probability));\n//         if (Probability_ == 0) {\n//             return true;\n//         } else {\n//             return false;\n//         }\n//     }\n\n//     /**\n//      *获取随机数_双闭区间\n//      *@param Min 最小数\n//      *@param Max 最大数\n//      */\n\n\n\n//     /**\n//      *位置限制\n//      *@param Target_Position 目标坐标\n//      *@param Min_Position 最小坐标\n//      *@param Max_Position 最大坐标\n//      */\n//     Position_Restricted(Target_Position: Vec3, Min_Position: Vec3, Max_Position: Vec3, Ortho_Height_Multiple: number) {\n//         /**设计分辨率 */\n//         let Design_Width = view.getDesignResolutionSize().width / 2 * Ortho_Height_Multiple;\n//         let Design_Height = view.getDesignResolutionSize().height / 2 * Ortho_Height_Multiple;\n\n//         Min_Position = v3(Min_Position.x + Design_Width, Min_Position.y + Design_Height, 0);\n//         Max_Position = v3(Max_Position.x - Design_Width, Max_Position.y - Design_Height, 0);\n//         if (Target_Position.x < Min_Position.x) {\n//             Target_Position = v3(Min_Position.x, Target_Position.y, 0);\n//         } else if (Target_Position.x > Max_Position.x) {\n//             Target_Position = v3(Max_Position.x, Target_Position.y, 0);\n//         }\n\n//         if (Target_Position.y < Min_Position.y) {\n//             Target_Position = v3(Target_Position.x, Min_Position.y, 0);\n//         } else if (Target_Position.y > Max_Position.y) {\n//             Target_Position = v3(Target_Position.x, Max_Position.y, 0);\n//         }\n//         return Target_Position;\n//     }\n\n//     /**获取两点角度\n//      *@param Start_Position 起点坐标\n//      *@param Finish_Positionition 终点坐标\n//      */\n//     Get_Angle(Start_Position: Vec3, Finish_Positionition: Vec3): number {\n//         const Delta_X = Finish_Positionition.x - Start_Position.x;\n//         const Delta_Y = Finish_Positionition.y - Start_Position.y;\n//         const AngleIn_Degrees = Math.atan2(Delta_Y, Delta_X) * (180 / Math.PI);\n//         return AngleIn_Degrees;\n//     }\n\n//     /**获取两点距离\n//      *@param Start_Position 起点坐标\n//      *@param Finish_Positionition 终点坐标\n//      */\n//     Get_Distance(Start_Position: Vec3, Finish_Positionition: Vec3) {\n//         if (!this.Get_Type_Is_Abnormal(Start_Position) || !this.Get_Type_Is_Abnormal(Finish_Positionition)) {\n//             console.warn(\"类型异常\");\n//             return;\n//         }\n//         return Number(Vec2.distance(Start_Position, Finish_Positionition).toFixed(2));\n//     }\n\n//     /**获取一个节点与一群子节点中相距最小的节点的下标和距离\n//      *@param Node 节点\n//      *@param Target_Node 目标父节点\n//      */\n//     Get_Min_Distance_Node(Node: Node, Target_Parent_Node: Node): object {\n//         if (!this.Get_Type_Is_Abnormal(Node) || !this.Get_Type_Is_Abnormal(Target_Parent_Node)) {\n//             console.warn(\"类型异常\");\n//             return;\n//         }\n//         if (Target_Parent_Node.children.length < 1) {\n//             return;\n//         }\n//         let Min_Index = 0;\n//         let Min_Distance = 999//this.Get_Distance(Node.getWorldPosition(), Target_Parent_Node.children[0].getWorldPosition());\n//         for (let i = 0; i < Target_Parent_Node.children.length; i++) {\n//             if (Node.parent === Target_Parent_Node) {\n//                 if (Node.getSiblingIndex() === i) {\n//                     continue;\n//                 }\n//             }\n//             let Distance = this.Get_Distance(Node.getWorldPosition(), Target_Parent_Node.children[i].getWorldPosition());\n//             if (Distance < Min_Distance) {\n//                 Min_Distance = Distance;\n//                 Min_Index = i;\n//             }\n//         }\n//         return [Min_Index, Min_Distance];\n//     }\n//     /**获取一个坐标与一群子节点中相距最小的节点的下标和距离\n//      *@param Node 节点\n//      *@param Target_Node 目标父节点\n//      */\n//     Get_Min_Distance_Position(Position: Vec3, Target_Parent_Node: Node): object {\n//         if (!this.Get_Type_Is_Abnormal(Position) || !this.Get_Type_Is_Abnormal(Target_Parent_Node)) {\n//             console.warn(\"类型异常\");\n//             return;\n//         }\n//         if (Target_Parent_Node.children.length < 1) {\n//             return;\n//         }\n//         let Min_Index = 0;\n//         let Min_Distance = 999;\n//         for (let i = 0; i < Target_Parent_Node.children.length; i++) {\n//             let Distance = this.Get_Distance(Position, Target_Parent_Node.children[i].position);\n//             // console.log(Distance,Target_Parent_Node.children[i].position,position);\n//             if (Distance < Min_Distance) {\n//                 Min_Distance = Distance;\n//                 Min_Index = i;\n//             }\n//         }\n//         return [Min_Index, Min_Distance];\n//     }\n\n//     /**获取一个角色与一群角色中相距最小的角色的下标和距离\n//     *@param Role 角色坐标\n//     *@param Target_Role_Arr 目标角色数组\n//     */\n//     Get_Min_Distance_Role(Role: Node, Target_Role_Arr: Node[]): object {\n//         if (!this.Get_Type_Is_Abnormal(Role) || !this.Get_Type_Is_Abnormal(Target_Role_Arr)) {\n//             console.warn(\"异常\");\n//             return;\n//         }\n//         if (Target_Role_Arr.length < 1) {\n//             return;\n//         }\n//         let Min_Index = 0;\n//         let Min_Distance = 999;\n//         for (let i = 0; i < Target_Role_Arr.length; i++) {\n//             if (Role == Target_Role_Arr[i]) {\n//                 continue;\n//             }\n//             let Distance = this.Get_Distance(Role.position.clone(), Target_Role_Arr[i].position.clone());\n//             if (Distance < Min_Distance) {\n//                 Min_Distance = Distance;\n//                 Min_Index = i;\n//             }\n//         }\n//         return [Min_Index, Min_Distance];\n//     }\n\n//     Get_Min_Distance_Pos_Arr(Pos: Vec3, Target_Pos_Arr: Vec3[]): object {\n//         if (!this.Get_Type_Is_Abnormal(Pos) || !this.Get_Type_Is_Abnormal(Target_Pos_Arr)) {\n//             console.warn(\"异常\");\n//             return;\n//         }\n//         if (Target_Pos_Arr.length < 1) {\n//             return;\n//         }\n//         let Min_Index = 0;\n//         let Min_Distance = 999;\n//         for (let i = 0; i < Target_Pos_Arr.length; i++) {\n//             let Distance = this.Get_Distance(Pos, Target_Pos_Arr[i]);\n//             if (Distance < Min_Distance) {\n//                 Min_Distance = Distance;\n//                 Min_Index = i;\n//             }\n//         }\n//         return [Min_Index, Min_Distance];\n//     }\n\n//     Get_All_Positions_Sorted(position: Vec3, Target_Parent_Node: Node): object {\n//         if (Target_Parent_Node.children.length < 1) {\n//             return;\n//         }\n//         let Min_Index_0 = 0;\n//         let Min_Distance_0 = 999;\n\n//         let Min_Index_1 = 0;\n//         let Min_Distance_1 = 999;\n\n//         let Min_Index_2 = 0;\n//         let Min_Distance_2 = 999;\n\n//         for (let i = 0; i < Target_Parent_Node.children.length; i++) {\n//             let Distance = this.Get_Distance(position, Target_Parent_Node.children[i].position);\n//             // console.log(Distance,Target_Parent_Node.children[i].position,position);\n//             if (Distance < Min_Distance_0) {\n//                 Min_Distance_0 = Distance;\n//                 Min_Index_0 = i;\n//             } else if (Distance < Min_Distance_1) {\n//                 Min_Distance_1 = Distance;\n//                 Min_Index_1 = i;\n//             } else if (Distance < Min_Distance_2) {\n//                 Min_Distance_2 = Distance;\n//                 Min_Index_2 = i;\n//             }\n//         }\n//         return [\n//             [Min_Index_0, Min_Distance_0],\n//             [Min_Index_1, Min_Distance_1],\n//             [Min_Index_2, Min_Distance_2]\n//         ];\n//     }\n\n\n\n//     /**获取一个节点的父节点个数\n//     *@param Node 节点\n//     */\n//     Get_Parent_Count(Node: Node): number {\n//         let Parent_Count: number = 0;\n//         while (Node.parent) {\n//             Parent_Count++;\n//             Node = Node.parent;\n//         }\n//         return Parent_Count;\n//     }\n\n//     /**生成一副扑克 */\n//     Get_Poker(): object {\n//         type Card = [number, number]; // 数组每个元素是两个数字，分别表示花色和点数\n//         const deck: Card[] = [];\n//         for (let suit = 1; suit <= 5; suit++) {\n//             for (let rank = 1; rank <= 13; rank++) {\n//                 if (suit !== 5) {\n//                     deck.push([suit, rank]); // 添加普通扑克牌\n//                 } else {\n//                     if (rank <= 2) {\n//                         deck.push([suit, rank]); // 添加小王、大王\n//                     }\n//                 }\n//             }\n//         }\n//         this.Get_Array_Shuffle(deck);\n//         return deck;\n//     }\n\n//     /**\n//      *\n//      *@param 传入一组数据进行排序 \n//      *@example\n//      *function sortByBalance(a: any[]): any[] {\n//             return a.sort((role1, role2) => role2.Role_Balance - role1.Role_Balance);\n//         }\n//         // 示例用法\n//         let a = [\n//         {\n//             \"Role_Ranking\": 0,\n//             \"Role_Avatar\": null,\n//             \"Role_Name\": \"\",\n//             \"Role_Balance\": 100\n//         },\n//         {\n//             \"Role_Ranking\": 0,\n//             \"Role_Avatar\": null,\n//             \"Role_Name\": \"\",\n//             \"Role_Balance\": 50\n//         },\n//         {\n//             \"Role_Ranking\": 0,\n//             \"Role_Avatar\": null,\n//             \"Role_Name\": \"\",\n//             \"Role_Balance\": 200\n//         }\n//         ];\n//         const sortedArray = sortByBalance(a);\n//         console.log(sortedArray); \n//     */\n//     sort_Ranking_Data(Ranking_Data: any[]): any[] {\n//         return Ranking_Data.sort((Data_1, Data_2) => Data_2.Role_Balance - Data_1.Role_Balance);\n//     }\n\n//     // Sort_Ordinate_Data(Node_: Node) {\n//     //     if (Node_ instanceof Node) {\n//     //         Node_.children.sort((Node_1, Node_2) => Node_1.position.y - Node_2.position.y);\n//     //         Node_.children.forEach((child) => this.Sort_Ordinate_Data(child));\n//     //     }\n//     //     return [...Node_.children];\n//     // }\n\n//     /**排序_纵坐标_数据 */\n//     Sort_Ordinate_Data(Node_: Node) {\n//         if (Node_ instanceof Node) {\n//             Node_.children.sort((Node_1, Node_2) => Node_2.position.y - Node_1.position.y);\n//             // for (let i = 0; i < Node_.children.length; i++) {\n//             //     this.Sort_Ordinate_Data(Node_.children[i]);\n//             // }\n//         }\n//         return [...Node_.children];\n//     }\n\n//     /**使该节点的显示层覆盖其父节点的其他子节点 */\n//     Set_Seat(Node_: Node) {\n//         if (Node_.parent) {\n//             const Sibling_ = Node_.parent.children;\n//             const Index_ = Sibling_.indexOf(Node_);\n//             if (Index_ !== -1 && Index_ !== Sibling_.length - 1) {\n//                 Node_.setSiblingIndex(Sibling_.length - 1);\n//             }\n//         }\n//     }\n\n//     // 判断两个节点是否相交\n//     isNodeInNode(nodeA: Node, nodeB: Node): Boolean {\n//         // 获取B节点的包围盒\n//         let widthB = nodeB.getComponent(UITransform).width;\n//         let heighB = nodeB.getComponent(UITransform).height;\n//         // 获取A节点的包围盒\n//         let widthA = nodeA.getComponent(UITransform).width;\n//         let heightA = nodeA.getComponent(UITransform).height;\n//         //判断A节点是否处于B包围盒中\n//         let rectB = new Rect(nodeB.worldPosition.x, nodeB.worldPosition.y, widthB, heighB);\n//         let rectA = new Rect(nodeA.worldPosition.x, nodeA.worldPosition.y, widthA, heightA);\n//         return rectB.intersects(rectA);\n//     }\n\n//     /**判断位置是否在指定位置范围 */\n//     Is_Specify_Range(Position_Target: Vec3, Position: Vec3, Range: number): Boolean {\n//         let Distance = this.Get_Distance(Position_Target, Position);\n//         if (Distance <= Range) {\n//             return true;\n//         } else {\n//             return false;\n//         }\n//     }\n\n\n\n//     /**\n//      *检查并修正坐标,使其与坐标数组中的点的距离大于等于指定距离\n//      *@param Target_Pos 目标坐标\n//      *@param Target_Node 目标节点\n//      *@param Dis 指定的距离\n//      *@returns 修正后的坐标\n//      */\n//     Check_And_Fix_Position(Target_Pos: Vec3, Target_Node: Node, Dis: number): Vec3 {\n//         // 克隆一个新的坐标对象\n//         let Target_Pos_ = Target_Pos.clone();\n//         let Pos_Arr: Vec3[] = [];\n//         for (let i = 0; i < Target_Node.children.length; i++) {\n//             Pos_Arr[i] = Target_Node.children[i].position;\n//         }\n//         // 循环检查坐标数组中的每个坐标\n//         for (let i = 0; i < Pos_Arr.length; i++) {\n//             const Pos = Pos_Arr[i].clone();\n//             // 计算两点之间的距离\n//             const Distance = this.Get_Distance(Target_Pos_.clone(), Pos.clone());\n//             // 如果距离小于指定距离,则修正坐标\n//             if (Distance < Dis) {\n//                 // 计算修正后的新坐标\n//                 const direction = Target_Pos_.clone().subtract(Pos.clone()).normalize();\n//                 Target_Pos_ = Pos.clone().add(direction.multiplyScalar(Dis));\n//             }\n//         }\n//         return Target_Pos_;\n//     }\n\n//     /**\n//      *根据两点坐标和距离,计算距离开始位置Dis的坐标\n//      *@param p1 起始点坐标\n//      *@param p2 目标点坐标\n//      *@param dis 距离起始点的距离\n//      *@returns 中间位置坐标\n//      */\n//     Get_Distance_Position(Start_Position: Vec3, Finish_Position: Vec3, Dis: number): Vec3 {\n//         // 计算两点之间的距离\n//         const Distance = this.Get_Distance(Start_Position.clone(), Finish_Position.clone());\n//         // 如果两点之间的距离小于或等于目标距离,则返回目标点坐标\n//         if (Distance <= Dis) {\n//             return Finish_Position.clone();\n//         }\n//         // 计算方向向量\n//         const Direction = Finish_Position.clone().subtract(Start_Position.clone()).normalize();\n//         // 计算中间位置坐标\n//         const Intermediate_Position = Start_Position.clone().add(Direction.multiplyScalar(Dis));\n//         return Intermediate_Position;\n//     }\n\n\n\n\n\n\n\n\n//     /**动画_节点_避让\n//      *@Node 节点\n//      *@Position 位置\n//      *@Time 时间\n//      *@Call 回调函数\n//      */\n//     Animation_Node_Avoid(Node: Node, Position: Vec3, Time?: number, Call: Function = () => { }) {\n\n//     }\n\n\n\n\n\n//     /**动画_预制体_展示 */\n//     Animation_Prefab_Show(Node: Node, Time: number, Call: Function = () => { }) {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(Time, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     let curScale = Number(ratio.toFixed(2));\n//                     Node.scale = v3(curScale, curScale, curScale);\n//                     // node.angle = 360 *(1 - Number(ratio.toFixed(2)));\n//                     return;\n//                 }\n//             })\n//             .call(() => {\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\n//                     this.scheduleOnce(() => {\n//                         Call && Call();\n//                     })\n//                 }\n//             })\n//             .start();\n//     }\n\n//     /**动画_心跳效果 */\n//     Animation_Heartbeat(node: Node) {\n//         tween(node).repeatForever(\n//             tween()\n//                 .to(0.5, { scale: v3(0.8, 0.8, 1) })\n//                 .to(0.3, { scale: v3(0.9, 0.9, 1) })\n//                 .to(0.45, { scale: v3(0.75, 0.75, 1) })\n//                 .to(0.3, { scale: v3(1, 1, 1) })\n//         )\n//             .start()\n//     }\n\n\n//     /**动画_受击效果\n//      *@pNode 节点\n//      *@Hit_time 受击时间\n//      *@Original_Color 初始颜色\n//      */\n//     Animation_Hit(Node: Node, Hit_time: number, Original_Color: Color, Call: Function = () => { }) {\n//         tween(Node.getComponent(Sprite))\n//             .to(Hit_time, { color: color(255, 0, 0, 255) })\n//             .call(() => {\n//                 Node.getComponent(Sprite).color = Original_Color;\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\n//                     Call && Call();\n//                 }\n//             })\n//             .start()\n//     }\n\n//     /**动画_死亡效果\n//      *@Node 节点\n//      *@Hit_time 受击时间\n//      *@Original_Color 初始颜色\n//      */\n//     Animation_Die(Node: Node, Hit_time: number, Original_Color: Color, Call: Function = () => { }) {\n\n//     }\n\n//     /**动画_消失效果 */\n//     Animation_Disappear(node: Node, disappear_time: number, Call: Function = () => { }) {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(disappear_time, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     let curScale = (1 - Number(ratio.toFixed(2)));\n//                     node.scale = v3(curScale, curScale, curScale);\n//                     // node.angle = 360 *Number(ratio.toFixed(2));\n//                     return;\n//                 }\n//             })\n//             .call(() => {\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\n//                     this.scheduleOnce(() => {\n//                         Call && Call();\n//                     })\n//                 }\n//             })\n//             .start();\n//     }\n\n//     /**动画_消失效果_反转 */\n//     Animation_Disappear_Reverse(node: Node, disappear_time: number, Call: Function = () => { }) {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(disappear_time, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     let curScale = Number(ratio.toFixed(2));\n//                     node.scale = v3(curScale, curScale, curScale);\n//                     // node.angle = 360 *(1 - Number(ratio.toFixed(2)));\n//                     return;\n//                 }\n//             })\n//             .call(() => {\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\n//                     this.scheduleOnce(() => {\n//                         Call && Call();\n//                     })\n//                 }\n//             })\n//             .start();\n//     }\n\n//     /**动画_闪光效果 */\n//     Animation_Flash(Node: Node, Call: Function = () => { }) {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(0.7, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     let color_value = 255 - (100 * (1 - Number(ratio.toFixed(2))));//255 - (100 *Number(ratio.toFixed(2)));\n//                     Node.getComponent(Sprite).color = color(color_value, color_value, color_value, color_value);\n//                     return;\n//                 }\n//             })\n//             .call(() => {\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\n//                     this.scheduleOnce(() => {\n//                         Call && Call();\n//                     })\n//                 }\n//             })\n//             .start();\n//     }\n\n\n\n\n//     /**动画_颜色_循环 */\n//     Animation_Color_repeatedly(Tag) {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(0.7, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     let color_value = 255 - (100 * Number(ratio.toFixed(2)));\n//                     this.node.getComponent(Sprite).color = color(color_value, color_value, color_value, 255);\n//                     return;\n//                 }\n//             })\n//             .tag(Tag)\n//             .call(() => {\n//                 startObj = { num: 0 };\n//                 endObj = { num: 100 };\n//                 tween(startObj)\n//                     .to(0.7, endObj, {\n//                         progress: (start: number, end: number, current: number, ratio: number): number => {\n//                             let color_value = 255 - (100 * (1 - Number(ratio.toFixed(2))));\n//                             this.node.getComponent(Sprite).color = color(color_value, color_value, color_value, 255);\n//                             return;\n//                         }\n//                     })\n//                     .tag(Tag)\n//                     .call(() => {\n//                         this.Animation_Color_repeatedly(Tag);\n//                     })\n//                     .start();\n//             })\n//             .start();\n//     }\n\n//     /**动画_金币收集\n//      *@node 要移动的节点\n//      *@node_target 要移动的目标节点\n//      *@collect_time 移动的时间\n//      *@Call 回调函数\n//      *@example\n//      *let node_target: Node = find(\"Canvas/Main/Balance\");\n//      *let collect_time = Vec2.distance(this.node.position, node_target.position) / 1000;\n//      *Tool_Script.instance.Gold_Collect_Animation(this.node, node_target, collect_time, () => {\n//      *     find(\"Resoure_Data\").getComponent(Resoure_Data_Script).Balance++;\n//      *     find(\"Resoure_Data\").getComponent(Resoure_Data_Script).Re_Balance();\n//      *})\n//      */\n//     Animation_Gold_Collect(node: Node, node_target: Node, collect_time: number, Call: Function = () => { }) {\n//         tween(node)\n//             .to(collect_time, { position: v3(node_target.position.x, node_target.position.y, 0), scale: v3(0.2, 0.2, 0) })\n//             .call(() => {\n//                 if (this.Get_Type_Is_Abnormal(Call)) {\n//                     this.scheduleOnce(() => {\n//                         Call && Call();\n//                     })\n//                 }\n//                 node.destroy();\n//             })\n//             .start()\n//     }\n\n//     /**\n//      *\n//      *@param\n//      *@example\n//      * let startObj = { num: 255 };\n//             let endObj = { num: 0 };\n//             tween(startObj)\n//                 .to(0.7, endObj, {\n//                     progress: (start: number, end: number, current: number, ratio: number): number => {\n//                         let curScale = (1 - Number(ratio.toFixed(2)));\n//                         this.node.scale = v3(curScale, curScale, curScale);\n//                         this.node.getComponent(Sprite).color = color(255, 255, 255, Math.floor(255 *(1 - ratio)));\n//                         return;\n//                     }\n//                 })\n//                 .start(); \n//      */\n//     Animation(Node: Node) {\n//         let startObj = { num: 0 };\n//         let endObj = { num: 100 };\n//         tween(startObj)\n//             .to(0.7, endObj, {\n//                 progress: (start: number, end: number, current: number, ratio: number): number => {\n//                     let curScale = Number(ratio.toFixed(2));\n//                     Node.scale = v3(curScale, curScale, curScale);\n//                     Node.angle = curScale;\n//                     Node.getComponent(Sprite).color = color(255, 255, 255, Math.floor(255 * ratio));\n//                     return;\n//                 }\n//             })\n//             .start();\n//     }\n\n\n//     /**获取在线玩家 */\n//     Get_Online_Players(Label: Label, OnlinePlayers: number) {\n//         let UpDataTime: number = this.Get_Random_Int(0, 10);\n//         let Change_Number: number = this.Get_Random_Int(-50, 50);\n//         OnlinePlayers += Change_Number;\n//         if (OnlinePlayers <= 0) {\n//             OnlinePlayers = 0;\n//         }\n//         Label.string = OnlinePlayers + \"\";\n//         this.scheduleOnce(() => {\n//             this.Get_Online_Players(Label, OnlinePlayers);\n//         }, UpDataTime)\n//     }\n\n//     /**随机生成名字 */\n//     Get_Random_Name(): string {\n//         const vowels = ['a', 'e', 'i', 'o', 'u'];\n//         const consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\n//         const nameLength = Math.floor(Math.random() * 8) + 5; // 随机生成名字的长度，范围为 1 到 10\n\n//         let name = '';\n//         let isVowel = Math.random() < 0.5; // 随机选择首字母是元音还是辅音\n\n//         for (let i = 0; i < nameLength; i++) {\n//             if (isVowel) {\n//                 name += vowels[Math.floor(Math.random() * vowels.length)];\n//             } else {\n//                 name += consonants[Math.floor(Math.random() * consonants.length)];\n//             }\n\n//             isVowel = !isVowel; // 每次循环切换元音和辅音\n//         }\n\n//         return name;\n//     }\n\n\n//     /**获取数独 */\n//     Get_Sudoku(): number[][] {\n\n//         // 检查同一行是否有相同的数字\n//         function checkRow(Arr: number[][], row: number, num: number): boolean {\n//             for (let i = 0; i < 9; i++) {\n//                 if (Arr[row][i] === num) {\n//                     return false;\n//                 }\n//             }\n//             return true;\n//         }\n//         // 检查同一列是否有相同的数字\n//         function checkColumn(Arr: number[][], col: number, num: number): boolean {\n//             for (let i = 0; i < 9; i++) {\n//                 if (Arr[i][col] === num) {\n//                     return false;\n//                 }\n//             }\n//             return true;\n//         }\n\n//         // 检查同一个3x3九宫格是否有相同的数字\n//         function checkGrid(Arr: number[][], startRow: number, startCol: number, num: number): boolean {\n//             for (let i = startRow; i < startRow + 3; i++) {\n//                 for (let j = startCol; j < startCol + 3; j++) {\n//                     if (Arr[i][j] === num) {\n//                         return false;\n//                     }\n//                 }\n//             }\n//             return true;\n//         }\n//         const Arr: number[][] = [];\n//         const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n//         // 随机打乱数字顺序\n//         for (let i = nums.length - 1; i > 0; i--) {\n//             const j = Math.floor(Math.random() * (i + 1));\n//             [nums[i], nums[j]] = [nums[j], nums[i]];\n//         }\n//         // 初始化二维数组\n//         for (let i = 0; i < 9; i++) {\n//             Arr[i] = [];\n//             for (let j = 0; j < 9; j++) {\n//                 Arr[i][j] = nums[(i * 3 + Math.floor(i / 3) + j) % 9];\n//             }\n//         }\n//         // 随机交换行和列\n//         for (let i = 0; i < 3; i++) {\n//             const r1 = Math.floor(Math.random() * 3) + i * 3;\n//             let r2 = r1;\n//             while (r2 === r1) {\n//                 r2 = Math.floor(Math.random() * 3) + i * 3;\n//             }\n//             for (let j = 0; j < 9; j++) {\n//                 [Arr[r1][j], Arr[r2][j]] = [Arr[r2][j], Arr[r1][j]];\n//             }\n\n//             const c1 = Math.floor(Math.random() * 3) + i * 3;\n//             let c2 = c1;\n//             while (c2 === c1) {\n//                 c2 = Math.floor(Math.random() * 3) + i * 3;\n//             }\n//             for (let j = 0; j < 9; j++) {\n//                 [Arr[j][c1], Arr[j][c2]] = [Arr[j][c2], Arr[j][c1]];\n//             }\n//         }\n//         // 确保每一行、每一列和每一个3x3九宫格都没有相同的数字\n//         for (let i = 0; i < 9; i++) {\n//             for (let j = 0; j < 9; j++) {\n//                 const num = Arr[i][j];\n//                 Arr[i][j] = 0; // 先将当前位置的数字设置为0\n\n//                 // 检查当前位置是否与同行、同列或同九宫格中的其他位置有相同的数字\n//                 if (\n//                     checkRow(Arr, i, num) &&\n//                     checkColumn(Arr, j, num) &&\n//                     checkGrid(Arr, i - (i % 3), j - (j % 3), num)\n//                 ) {\n//                     Arr[i][j] = num; // 如果没有相同的数字，则将当前位置设置为该数字\n//                 } else {\n//                     j--; // 如果有相同的数字，则重新尝试下一个数字\n//                 }\n//             }\n//         }\n//         return Arr;\n//     }\n\n//     //交换两个节点的索引\n//     Swap_SiblingIndex(Node_1: Node, Node_2: Node): void {\n//         const Index_1 = Node_1.getSiblingIndex();\n//         const Index_2 = Node_2.getSiblingIndex();\n//         Node_1.setSiblingIndex(Index_1);\n//         Node_2.setSiblingIndex(Index_2);\n//     }\n\n\n\n\n\n\n\n\n// }\n\n// /**暴露函数 */\n// function Fun(parameter: number): number {\n//     return parameter;\n// }\n\n// export { Fun };\n\n\n\n\n\n\n\n\n\n\n"]}