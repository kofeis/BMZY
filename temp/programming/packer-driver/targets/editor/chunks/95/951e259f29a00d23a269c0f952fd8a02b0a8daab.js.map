{"version":3,"sources":["file:///D:/Cocos/XHAT/BMZY/assets/Script/Game/GameMode/PanelMathMatch_.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAIA;AAIA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAYA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AAEA;AAEA;AAEA","sourcesContent":["// import { _decorator, color, Component, find, Label, Layout, log, math, Node, Prefab, Tween, tween, v3, Vec3, Animation, Sprite, RichText, sys } from 'cc';\r\n// import { PanelTemplate } from './PanelTemplate';\r\n// import { Tool_Event } from '../../Tool/Tool_Event';\r\n// import { Tool_Animation } from '../../Tool/Tool_Animation';\r\n// import { Tool_UI } from '../../Tool/Tool_UI';\r\n// import { Tool_Other } from '../../Tool/Tool_Other';\r\n// import { Tool_Console } from '../../Tool/Tool_Console';\r\n// import { PlatformApi } from '../../Other/SDK/PlatformApi';\r\n// import { GravityPlatform } from '../../Other/GeSdk/GravityPlatform';\r\n// const { ccclass, property } = _decorator;\r\n\r\n\r\n\r\n// /**数据接口 */\r\n// export interface DataMathMatch {\r\n//     Level: number, Key: string[], Value: number[], Result: number[], Count: number;\r\n// }\r\n\r\n// @ccclass('PanelMathMatch')\r\n// export class PanelMathMatch extends PanelTemplate {\r\n\r\n//     Interactable: boolean = true;\r\n\r\n//     GameTimeAll: number = 180;\r\n//     GameTimeIng: number = 0\r\n//     GameTime: number = 0;\r\n\r\n//     /**返回按钮 */\r\n//     BtnBreak: Node = null;\r\n//     PanelFH: Node = null;\r\n//     GameData: DataMathMatch = null;\r\n\r\n//     /**有效目标 */\r\n//     KeyTarget: Node[] = [];\r\n//     /**存在状态 */\r\n//     KeyExitState: boolean[] = [];\r\n\r\n//     /**存在节点 */\r\n//     KeyExitValue: Node[] = [];\r\n\r\n\r\n//     /**阴影索引 */\r\n//     KeyShadowIndex: number = -1;\r\n\r\n\r\n//     //Value节点上一次在Key节点的位置\r\n//     LastKeyIndex: number[] = [];\r\n//     /**有效目标 */\r\n//     ValueTarget: Node[] = [];\r\n//     ValuePos: Vec3[] = [];\r\n//     /**Value有效目标副本 */\r\n//     ValueTargetC: Node[] = [];\r\n\r\n//     KeyShadow: Prefab = null;\r\n//     /**有效距离 */\r\n//     OnDistance: number = 50;\r\n\r\n\r\n//     /**正确动画节点 */\r\n//     AnimCorrectNode: Node[] = [];\r\n//     /**错误动画节点 */\r\n//     AnimWrongNode: Node[] = [];\r\n//     TouchNode: Node = null;\r\n\r\n//     TipLabel: Node = null;\r\n//     TipNode: Node = null;\r\n\r\n\r\n//     Obj_Start = { num: 0 }\r\n//     Time: number = 0;\r\n//     Time_Max: number = 15;//15\r\n\r\n//     Obj_StartP = { num: 0 }\r\n//     TimeP: number = 0;\r\n//     Time_MaxP: number = 45;//45\r\n\r\n//     async onLoad() {\r\n//         super.onLoad();\r\n//     }\r\n\r\n//     async onEnable() {\r\n//         if (!this.IsInit) {\r\n//             await this.LoadPanel();\r\n//         }\r\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\")\r\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\")\r\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxE\")\r\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\")\r\n//         this.GameStart();\r\n//         //    this.Resoure_Data.Music_Play(\"Audio/BgmGame\");\r\n//     }\r\n\r\n//     start() {\r\n\r\n//     }\r\n\r\n//     Timing() {\r\n//         this.Obj_Start = { num: 0 };\r\n//         Tool_Animation.instance.Async_Function_Target(this.Time_Max, this.Obj_Start, () => {\r\n//             console.log(\"无操作播放\");\r\n//             Tool_Animation.instance.Anim_Frame_Play_Plus(this.BtnTip.getChildByName(\"Icon\").getComponent(Animation), null, null, null, null, null, 3, 0, () => {\r\n//                 this.Timing();\r\n//             });\r\n//         })\r\n//     }\r\n//     TimStop() {\r\n//         console.log(\"重置无操作播放计时\");\r\n//         Tool_Animation.instance.Tween_Stop_Target(this.Obj_Start);\r\n//         this.Timing();\r\n//     }\r\n\r\n//     TimingP() {\r\n//         this.Obj_StartP = { num: 0 };\r\n//         Tool_Animation.instance.Async_Function_Target(this.Time_MaxP, this.Obj_StartP, () => {\r\n//             console.log(\"误操作播放\");\r\n//             Tool_Animation.instance.Anim_Frame_Play_Plus(this.BtnTip.getChildByName(\"Icon\").getComponent(Animation), null, null, null, null, null, 3, 0, () => {\r\n//                 this.TimingP();\r\n//             });\r\n//         })\r\n//     }\r\n//     TimStopP() {\r\n//         console.log(\"重置误操作播放计时\");\r\n//         Tool_Animation.instance.Tween_Stop_Target(this.Obj_StartP);\r\n//         this.TimingP();\r\n//     }\r\n\r\n\r\n//     /**加载面板 */\r\n//     async LoadPanel(): Promise<void> {\r\n//         return new Promise(async (resolve, reject) => {\r\n//             /**绑定关键节点 */\r\n//             this.BtnSetting = find(\"BtnSetting\", this.node);\r\n\r\n//             this.PanelTip = find(\"PanelTip\", this.node);\r\n//             this.BtnTip = find(\"BtnTip\", this.node);\r\n//             this.BtnTipClose = find(\"BtnTipClose\", this.PanelTip);\r\n//             this.BtnTipGet = find(\"BtnTipGet\", this.PanelTip);\r\n\r\n//             this.PanelFH = find(\"PanelFH\", this.node);\r\n\r\n\r\n//             this.PanelVictory = find(\"PanelVictory\", this.node);\r\n//             this.PanelFail = find(\"PanelFail\", this.node);\r\n//             this.BtnNext = find(\"BtnNext\", this.PanelVictory);\r\n\r\n//             // this.BtnGet = find(\"BtnGet\", this.PanelTip);\r\n//             this.BtnExit = find(\"BtnExit\", this.node);\r\n//             /**注册按钮事件 */\r\n//             await this.OnBtn(this.Game_Script.AnimSwitch);\r\n//             this.IsInit = true;\r\n//             resolve();\r\n//             this.KeyShadow = await this.Resoure_Data.Load_Prefab(\"Prefab/PanelMathMatch/KeyShadow\");\r\n//         });\r\n//     }\r\n\r\n//     /**注册按钮 */\r\n//     async OnBtn(AnimSwitch: boolean = false) {\r\n\r\n//         /**设置按钮 */\r\n//         const BtnSettingCall = () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             this.Game_Script.UpdatePanelSetting(true);\r\n//         }\r\n\r\n//         /**关闭按钮 */\r\n//         const BtnBreakCall = () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             this.node.active = false;\r\n//         }\r\n\r\n//         /**重新游戏 */\r\n//         const BtnReStartCall = () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             PlatformApi.instance.shareAppMessage(() => { });\r\n//             this.Game_Script.MathMatchLevel--;\r\n//             this.Game_Script.MathMatchScore -= this.Score;\r\n//             this.Game_Script.DataSet();\r\n//             this.GameStart();\r\n//         }\r\n//         /**下一关按钮 */\r\n//         const BtnNextCall = () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             this.GameStart();\r\n//         }\r\n\r\n//         const BtnTipCall = async () => {\r\n//             if (this.ValueTarget.length == 0) {\r\n//                 return;\r\n//             }\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             if (this.Game_Script.PropNum > 0) {\r\n//                 TipCall();\r\n//             } else {\r\n//                 this.PanelTip.active = true;\r\n//             }\r\n\r\n//         }\r\n//         const BtnTipCloseCall = async () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             this.PanelTip.active = false;\r\n//         }\r\n//         const BtnTipGetCall = async () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             PlatformApi.instance.showVideoAd(() => {\r\n//                 this.Game_Script.PropNum += 200;\r\n//                 this.Game_Script.DataSet();\r\n//                 this.UpdateProp();\r\n//                 this.PanelTip.active = false;\r\n//             }, () => {\r\n\r\n//             })\r\n//         }\r\n\r\n\r\n//         /**提示 */\r\n//         const TipCall = async () => {\r\n\r\n//             // this.Game_Script.OnMessage(\"没有更多关卡了\");\r\n//             if (!this.Interactable) {\r\n//                 return\r\n//             }\r\n\r\n//             // if (this.TipLabel != null || this.TipNode != null) {\r\n//             //     return;\r\n//             // }\r\n\r\n//             //剩下的数字\r\n//             let ValueNumber: number[] = [];\r\n//             for (let i = 0; i < this.ValueTarget.length; i++) {\r\n//                 ValueNumber.push(Number(this.ValueTarget[i].getChildByName(\"Label\").getComponent(Label).string));\r\n//             }\r\n//             if (ValueNumber == undefined) {\r\n//                 this.TipLabel = null;\r\n//                 this.TipNode = null;\r\n//                 return;\r\n//             }\r\n\r\n//             this.Game_Script.PropNum--;\r\n//             this.Game_Script.DataSet();\r\n//             this.UpdateProp();\r\n\r\n//             console.log(\"剩下的数字\", ValueNumber);\r\n\r\n//             let NullGIndex = Tool_Other.instance.Get_Random_Int(0, ValueNumber.length - 1);\r\n\r\n//             //索引\r\n//             console.log(\"V索引\", NullGIndex);\r\n//             //答案\r\n//             console.log(\"答案\", ValueNumber[NullGIndex]);\r\n\r\n//             for (let j = 0; j < this.GameData.Result.length; j++) {\r\n//                 //如何是正确答案\r\n//                 if (this.GameData.Result[j] == ValueNumber[NullGIndex]) {\r\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(this.KeyTarget[j].worldPosition, this.ValueTargetC);\r\n//                     if (Obj.Distance < this.OnDistance) {\r\n//                         let Num = Number(this.ValueTargetC[Obj.Index].getChildByName(\"Label\").getComponent(Label).string);\r\n//                         console.warn(\"当前答案\", Num);\r\n//                         if (Num == ValueNumber[NullGIndex]) {\r\n//                             continue;\r\n//                         } else {\r\n//                             console.error(\"K索引\", j);\r\n//                             console.error(Obj);\r\n//                             let TipLabel = this.KeyTarget[j].getChildByName(\"Label\");\r\n//                             // this.TipLabel.getComponent(Label).string = ValueNumber[NullGIndex] + \"\";\r\n//                             // Tool_UI.instance.Set_Color_Label(this.TipLabel, color(0, 155, 0, 255));\r\n//                             let TipNode = this.ValueTarget[NullGIndex];\r\n//                             this.TipStart(TipNode, TipLabel);\r\n//                             let TouchNode = this.ValueTargetC[Obj.Index];\r\n//                             Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\r\n//                             let i = this.ValueTarget.indexOf(TouchNode);\r\n//                             let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\r\n//                             let Key = find(\"Key\", this.node);\r\n//                             let Value = find(\"Value\", this.node);\r\n//                             let Temp = find(\"Temp\", this.node);\r\n//                             let ColorOff: math.Color = color(255, 255, 155, 255);\r\n//                             let ColorOn: math.Color = color(155, 255, 155, 255);\r\n//                             Tool_Animation.instance.Tween_Stop_Target(TouchNode);\r\n//                             TouchNode.scale = v3(1, 1, 1);\r\n//                             TouchNode.angle = 0;\r\n//                             Tool_UI.instance.Set_SpriteFrame(TouchNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                             Tool_UI.instance.Set_Color_Label(TouchNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n//                             Tool_UI.instance.Node_Index_Set(TouchNode, -1);\r\n\r\n//                             // 1. 获取原节点（当前占用目标位置的节点）\r\n//                             const OriginalNode = this.KeyExitValue[Obj.Index];\r\n//                             // 2. 将原节点移回默认位置（或 LastKeyIndex 的位置）\r\n//                             //原上次索引\r\n//                             let OriginalLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, OriginalNode)\r\n//                             //现上次索引\r\n//                             let CurrentLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, TouchNode)\r\n//                             // console.log(OriginalLastKeyIndex, CurrentLastKeyIndex);\r\n//                             // console.log(\"原上次索引\", this.LastKeyIndex[OriginalLastKeyIndex], \"现上次索引\", this.LastKeyIndex[CurrentLastKeyIndex]);\r\n\r\n//                             // this.TipStart();\r\n//                             // console.log(\"是否存在\", IsExit);\r\n//                             if (!IsExit) {\r\n//                                 Tool_UI.instance.Arr_Increase(this.ValueTarget, TouchNode);\r\n//                                 //题目节点的索引\r\n//                                 let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\r\n//                                 let KeyNodeValueT: string = \"N\";\r\n//                                 this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                                 // console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                                 // console.log(this.GameData);\r\n//                                 if (this.LastKeyIndex[i] != null) {\r\n//                                     this.KeyExitState[this.LastKeyIndex[i]] = false;\r\n//                                     this.KeyExitValue[this.LastKeyIndex[i]] = null;\r\n//                                     Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                                 }\r\n//                                 // 重置当前目标位置的状态（如果之前已被占用）\r\n//                                 if (this.KeyExitState[Obj.Index]) {\r\n//                                     this.KeyExitState[Obj.Index] = false;\r\n//                                     this.KeyExitValue[Obj.Index] = null;\r\n//                                     Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                                 }\r\n//                                 this.LastKeyIndex[i] = null;\r\n//                             }\r\n//                             this.UpdateUIValue();\r\n//                             return;\r\n//                         }\r\n\r\n//                     } else {\r\n//                         let TipLabel = this.KeyTarget[j].getChildByName(\"Label\");\r\n//                         // this.TipLabel.getComponent(Label).string = ValueNumber[NullGIndex] + \"\";\r\n//                         // Tool_UI.instance.Set_Color_Label(this.TipLabel, color(0, 155, 0, 255));\r\n//                         // console.error(\"K索引\", j);\r\n//                         // console.error(Obj);\r\n//                         let TipNode = this.ValueTarget[NullGIndex];\r\n\r\n//                         this.TipStart(TipNode, TipLabel);\r\n//                         return\r\n//                     }\r\n\r\n//                 }\r\n\r\n//             }\r\n\r\n//         }\r\n\r\n//         /**设置按钮事件 */\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnSetting, BtnSettingCall);\r\n\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnTip, BtnTipCall);\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnTipClose, BtnTipCloseCall);\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnTipGet, BtnTipGetCall);\r\n\r\n\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnNext, BtnNextCall);\r\n\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnExit, BtnBreakCall);\r\n\r\n\r\n\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelVictory.getChildByName(\"BtnNext\"), BtnNextCall);\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelVictory.getChildByName(\"BtnReStart\"), BtnReStartCall);\r\n\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFail.getChildByName(\"BtnNext\"), BtnNextCall);\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFail.getChildByName(\"BtnBreak\"), BtnBreakCall);\r\n\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFH.getChildByName(\"Btn\"), () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             PlatformApi.instance.showVideoAd(() => {\r\n//                 this.PanelFH.active = false;\r\n//                 this.GameTime = this.GameTimeAll;\r\n//                 let ComponentLabel = find(\"Title/Bgg/Timer\", this.node).getComponent(Label);\r\n//                 this.Game_Script.Timer(ComponentLabel, this.GameTime, () => {\r\n//                     this.PanelFH.active = true;\r\n//                     this.Game_Script.TimerStop();\r\n//                 }, \"S\", () => {\r\n//                     this.GameTimeIng++;\r\n//                 });\r\n//             }, () => {\r\n\r\n//             })\r\n\r\n\r\n//         });\r\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFH.getChildByName(\"BtnClose\"), () => {\r\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\r\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//             }\r\n//             this.PanelFH.active = false;\r\n//             this.GameFailed();\r\n//         });\r\n\r\n//         /**设置按钮动画 */\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnSetting, AnimSwitch);\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnTip, AnimSwitch);\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnTipClose, AnimSwitch);\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnTipGet, AnimSwitch);\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnNext, AnimSwitch);\r\n\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnExit, AnimSwitch);\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFail.getChildByName(\"BtnNext\"), AnimSwitch);\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFail.getChildByName(\"BtnBreak\"), AnimSwitch);\r\n\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFH.getChildByName(\"Btn\"), AnimSwitch);\r\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFail.getChildByName(\"BtnBreak\"), AnimSwitch);\r\n\r\n\r\n//         let Key = find(\"Key\", this.node);\r\n//         let Value = find(\"Value\", this.node);\r\n//         for (let i = 0; i < Value.children.length; i++) {\r\n//             this.ValuePos.push(Value.children[i].position.clone());\r\n//         }\r\n//     }\r\n\r\n\r\n//     /**初始化数据 */\r\n//     async InitData() {\r\n\r\n//         this.Game_Script.UpdateScore();\r\n\r\n//         console.log(\"初始化数据\");\r\n//         /**注册按钮事件 */\r\n//         // await this.OnBtn(this.Game_Script.AnimSwitch);\r\n//         this.KeyTarget = [];\r\n//         this.KeyExitState = [];\r\n//         this.KeyExitValue = [];\r\n\r\n//         this.ValueTarget = [];\r\n//         this.ValueTargetC = [];\r\n//         this.LastKeyIndex = [];\r\n\r\n//         this.AnimCorrectNode = [];\r\n//         this.AnimWrongNode = [];\r\n\r\n//         this.Interactable = true;\r\n\r\n\r\n\r\n\r\n//         this.TouchNode = null;\r\n//         this.TipLabel = null;\r\n//         this.TipNode = null;\r\n\r\n//         this.GameTimeIng = 0;\r\n\r\n\r\n//         // this.Game_Script.MathMatchLevel = 1\r\n\r\n//         if (this.Game_Script.MathMatchLevel < 0) {\r\n//             this.Game_Script.MathMatchLevel = 0;\r\n//             this.Game_Script.DataSet();\r\n//         }\r\n\r\n\r\n//         let F = {\r\n//             \"Level\": 6,\r\n//             \"Key\": [\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\r\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\"\r\n//             ],\r\n//             \"Value\": [],\r\n//             \"Result\": [],\r\n//             \"Count\": 0\r\n//         }\r\n\r\n\r\n//         const Json = await this.Resoure_Data.Load_Json(\"Json/mathmatch\");\r\n//         const JsonData = Json[\"Data\"];\r\n//         console.log(JsonData);\r\n\r\n//         this.GameData = null;\r\n//         if (this.Game_Script.MathMatchLevel >= JsonData.length) {\r\n//             this.Game_Script.OnMessage(\"没有更多关卡了\");\r\n//             this.GameData = this.Resoure_Data.Copy_Deep(JsonData[JsonData.length - 1]);\r\n//         } else {\r\n//             this.GameData = this.Resoure_Data.Copy_Deep(JsonData[this.Game_Script.MathMatchLevel]);\r\n//         }\r\n//         console.log(this.GameData);\r\n\r\n//         this.Game_Script.IsHint = false;\r\n//         this.Game_Script.IsContinue = false;\r\n//         this.GameTime = this.GameTimeAll;\r\n//         let ComponentLabel = find(\"Title/Bgg/Timer\", this.node).getComponent(Label);\r\n//         this.Game_Script.Timer(ComponentLabel, this.GameTimeAll, () => {\r\n//             console.log(\"失败\");\r\n//             this.PanelFH.active = true;\r\n//             this.Game_Script.TimerStop();\r\n//         }, \"S\", () => {\r\n//             this.GameTimeIng++;\r\n//         });\r\n\r\n//     }\r\n\r\n//     /**初始化界面 */\r\n//     async InitInterface() {\r\n\r\n//         if (this.Game_Script.MathMatchLevel == 0) {\r\n//             find(\"Hand\", this.node).getComponent(Animation).play();\r\n//             this.Game_Script.OnMessage(\"将需要的数字拖动到空格上\");\r\n//         }\r\n//         if (this.Game_Script.MathMatchLevel == 1) {\r\n//             find(\"ND\", this.node).getComponent(Animation).play();\r\n//         }\r\n\r\n//         this.PanelVictory.active = false;\r\n//         this.PanelFail.active = false;\r\n//         this.PanelTip.active = false;\r\n//         this.PanelFH.active = false;\r\n//         this.UpdateProp();\r\n//         this.node.getChildByName(\"Title\").getChildByName(\"Leves\").getComponent(Label).string = `第${this.Game_Script.MathMatchLevel + 1}关`;\r\n//         find(\"Temp\", this.node).destroyAllChildren();\r\n//         let Key = find(\"Key\", this.node);\r\n//         let Value = find(\"Value\", this.node);\r\n\r\n//         for (let i = 0; i < Key.children.length; i++) {\r\n//             Key.children[i].active = false;\r\n//             Tool_UI.instance.Set_Color_Sprite(Key.children[i].getChildByName(\"Bg\").getChildByName(\"Sp\"), color(255, 255, 155, 255));\r\n//         }\r\n\r\n//         for (let i = 0; i < Value.children.length; i++) {\r\n//             Value.children[i].active = false;\r\n//             Value.children[i].scale = v3(1, 1, 1);\r\n//             Value.children[i].angle = 0;\r\n\r\n//             Tool_UI.instance.Set_SpriteFrame(Value.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//             Tool_UI.instance.Set_Color_Label(Value.children[i].getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n\r\n//         }\r\n\r\n//         if (this.GameData == null) {\r\n//             console.log(\"配置错误\");\r\n//             return;\r\n//         }\r\n\r\n\r\n//         for (let i = 0; i < Key.children.length; i++) {\r\n//             Key.children[i].active = true;\r\n//             switch (this.GameData.Key[i]) {\r\n//                 case \"U\":\r\n//                     Key.children[i].active = false;\r\n//                     break;\r\n//                 case \"N\":\r\n//                     Key.children[i].getChildByName(\"Label\").getComponent(Label).string = \"\";\r\n//                     this.KeyTarget.push(Key.children[i]);\r\n//                     this.KeyExitState.push(false);\r\n//                     this.KeyExitValue.push(null);\r\n//                     Tool_UI.instance.Set_SpriteFrame(Key.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\"));\r\n//                     break;\r\n//                 default:\r\n//                     let Str: string = \"\";\r\n//                     switch (this.GameData.Key[i]) {\r\n//                         // case \"/\":\r\n//                         //     Str = \"÷\";\r\n//                         // break;\r\n//                         case \"X\":\r\n//                             Str = \"x\";\r\n//                             break;\r\n//                         default:\r\n//                             Str = this.GameData.Key[i];\r\n//                             break;\r\n//                     }\r\n//                     Key.children[i].getChildByName(\"Label\").getComponent(Label).string = Str\r\n\r\n//                     Tool_UI.instance.Set_SpriteFrame(Key.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\"));\r\n//                     break;\r\n//             }\r\n//         }\r\n\r\n//         let Temp = find(\"Temp\", this.node);\r\n//         let ColorOff: math.Color = color(255, 255, 155, 255);\r\n//         let ColorOn: math.Color = color(155, 255, 155, 255);\r\n\r\n\r\n//         for (let i = 0; i < Value.children.length; i++) {\r\n//             const Shadow = Value.children[i].getChildByName(\"Shadow\");\r\n//             const ComponentLabel1 = Value.children[i].getChildByName(\"Label\").getComponent(Label);\r\n//             Shadow.active = false;\r\n//             Value.children[i].active = i < this.GameData.Value.length ? true : false;\r\n//             if (Value.children[i].active) {\r\n//                 this.ValueTarget.push(Value.children[i]);\r\n//                 this.ValueTargetC.push(Value.children[i]);\r\n//                 this.LastKeyIndex.push(null);\r\n//                 Value.children[i].position = this.ValuePos[i];\r\n//                 ComponentLabel1.string = this.GameData.Value[i] + \"\";\r\n\r\n//                 Tool_Event.instance.Off_Event_TOUCH_All(Value.children[i]);\r\n\r\n\r\n\r\n//                 const TouchNode = Value.children[i];\r\n//                 const Shadow = TouchNode.getChildByName(\"Shadow\");\r\n//                 const ComponentLabel = TouchNode.getChildByName(\"Label\").getComponent(Label);\r\n//                 const Check_Shadow = () => {\r\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\r\n//                     if (Obj.Distance <= this.OnDistance) {\r\n//                         if (this.KeyShadowIndex == Obj.Index) {\r\n//                             return;\r\n//                         }\r\n//                         Temp.destroyAllChildren();\r\n//                         this.KeyShadowIndex = Obj.Index;\r\n//                         Tool_UI.instance.Set_Prefab_Node(this.KeyShadow, Temp, this.KeyTarget[Obj.Index], \"\")\r\n//                     } else {\r\n//                         Temp.destroyAllChildren();\r\n//                         this.KeyShadowIndex = -1;\r\n//                     }\r\n//                 }\r\n\r\n\r\n//                 Tool_Event.instance.On_Event_TOUCH_Drag(TouchNode, () => this.Interactable, async (Event, Pos_Touch_Start) => {\r\n//                     if (this.GameData == null) {\r\n//                         this.Interactable = false;\r\n//                         console.log(\"配置错误\");\r\n//                         return;\r\n//                     }\r\n//                     this.TouchNode = TouchNode;\r\n//                     console.log(this.LastKeyIndex, i, this.ValueTargetC.indexOf(TouchNode));\r\n//                     /**触摸开始回调 */\r\n//                     this.Resoure_Data.Sound_Play(\"Audio/NumClick\");\r\n//                     if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//                         PlatformApi.instance.vibrateShort();\r\n//                     }\r\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\r\n//                     Tool_Animation.instance.Tween_Stop_Target(this.KeyTarget[Obj.Index]);\r\n//                     this.KeyTarget[Obj.Index].scale = v3(1, 1, 1);\r\n//                     this.KeyTarget[Obj.Index].angle = 0;\r\n//                     Tool_Animation.instance.Tween_Stop_Target(TouchNode);\r\n//                     TouchNode.scale = v3(1, 1, 1);\r\n//                     TouchNode.angle = 0;\r\n//                     Tool_UI.instance.Set_SpriteFrame(TouchNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                     Tool_UI.instance.Set_Color_Label(TouchNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n\r\n//                     Tool_UI.instance.Node_Index_Set(TouchNode, -1);\r\n//                     Shadow.active = true;\r\n//                     Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos_Touch_Start.clone().add(v3(0, 25, 0)), 0.02, null, \"smooth\");\r\n//                     let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\r\n//                     if (!IsExit) {\r\n//                         tween(TouchNode)\r\n//                             .to(0.25, { scale: v3(1, 1, 1) }, { easing: \"backOut\" })\r\n//                             .start();\r\n//                     }\r\n//                     Check_Shadow();\r\n//                 }, (Event, Pos_Touch_Start) => {\r\n//                     /**触摸移动回调 */\r\n//                     Check_Shadow();\r\n//                 }, async (Event, Pos_Touch_Start, Pos_Touch_End) => {\r\n//                     /**触摸结束回调 */\r\n//                     Shadow.active = false;\r\n//                     let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\r\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\r\n\r\n//                     // 1. 获取原节点（当前占用目标位置的节点）\r\n//                     const OriginalNode = this.KeyExitValue[Obj.Index];\r\n//                     // 2. 将原节点移回默认位置（或 LastKeyIndex 的位置）\r\n//                     //原上次索引\r\n//                     let OriginalLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, OriginalNode)\r\n//                     //现上次索引\r\n//                     let CurrentLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, TouchNode)\r\n//                     console.log(OriginalLastKeyIndex, CurrentLastKeyIndex);\r\n//                     console.log(\"原上次索引\", this.LastKeyIndex[OriginalLastKeyIndex], \"现上次索引\", this.LastKeyIndex[CurrentLastKeyIndex]);\r\n\r\n//                     if (Obj.Distance <= this.OnDistance) {\r\n\r\n//                         // this.TipReset();\r\n\r\n//                         //目标位置被占用\r\n//                         if (this.KeyExitState[Obj.Index] && this.LastKeyIndex[i] != Obj.Index) {\r\n//                             if (this.LastKeyIndex[i] != null) {\r\n//                                 this.KeyTarget[Obj.Index].active = false;\r\n//                                 this.KeyTarget[this.LastKeyIndex[i]].active = false;\r\n//                                 // 将原节点移动到 LastKeyIndex 的位置\r\n//                                 const OriginalNodePos = Tool_UI.instance.Get_Target_Node_Local_Pos(OriginalNode, this.KeyTarget[this.LastKeyIndex[i]]);\r\n//                                 this.Interactable = false;\r\n//                                 Tool_Animation.instance.Animation_Node_Move_Time(OriginalNode, OriginalNodePos, 0.25, async () => {\r\n//                                     this.Interactable = true;\r\n//                                     this.KeyTarget[Obj.Index].active = true;\r\n//                                     this.KeyTarget[this.LastKeyIndex[i]].active = true;\r\n//                                     //交换索引\r\n\r\n//                                     console.log(this.LastKeyIndex, 1);\r\n//                                     console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\r\n//                                     console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\r\n\r\n//                                     const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\r\n//                                     this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\r\n//                                     this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\r\n\r\n//                                     //交换节点的索引\r\n//                                     let KeyNodeIndexL = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[OriginalLastKeyIndex]]);\r\n//                                     let KeyNodeValueL = OriginalNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                                     //题目节点的索引\r\n//                                     let KeyNodeIndexT = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                                     let KeyNodeValueT = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                                     this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\r\n//                                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n\r\n//                                     console.log(\"交换节点的索引\", KeyNodeIndexL, \"交换节点的数值\", KeyNodeValueL);\r\n//                                     console.log(\"触摸节点的索引\", KeyNodeIndexT, \"触摸节点的数值\", KeyNodeValueT);\r\n//                                     console.log(this.GameData);\r\n\r\n//                                     this.FindAllEquationIndices_(this.GameData.Key);\r\n\r\n\r\n\r\n//                                     Tool_Animation.instance.Tween_Stop_Target(OriginalNode);\r\n//                                     OriginalNode.scale = v3(0.9, 0.9, 1);\r\n//                                     OriginalNode.angle = 0;\r\n//                                     Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                                     Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n\r\n//                                     // console.error(OriginalNode, TouchNode);\r\n\r\n//                                     await Tool_Animation.instance.Async_Wait(0.05);\r\n//                                     this.TouchNode = OriginalNode;\r\n//                                     this.FindAllEquationIndices_(this.GameData.Key);\r\n\r\n//                                 }, \"smooth\");\r\n//                                 // 更新原节点的状态为占用 LastKeyIndex\r\n//                                 this.KeyExitState[this.LastKeyIndex[i]] = true;\r\n//                                 this.KeyExitValue[this.LastKeyIndex[i]] = OriginalNode;\r\n//                             } else {\r\n//                                 // 如果 LastKeyIndex 为 null，将原节点放回 ValueTarget 池\r\n//                                 Tool_UI.instance.Arr_Increase(this.ValueTarget, OriginalNode);\r\n\r\n//                                 Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                                 Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n\r\n//                                 //交换索引\r\n//                                 console.log(this.LastKeyIndex, 2);\r\n//                                 console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\r\n//                                 console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\r\n\r\n\r\n//                                 const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\r\n//                                 this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\r\n//                                 this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\r\n\r\n//                                 //题目节点的索引\r\n//                                 let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                                 let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                                 this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                                 console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                                 console.log(this.GameData);\r\n\r\n\r\n//                                 this.FindAllEquationIndices_(this.GameData.Key, 0.2);\r\n//                             }\r\n//                             // 3. 将新节点(TouchNode)放置到目标位置（Obj.Index）\r\n//                             this.KeyExitState[Obj.Index] = true;\r\n//                             this.KeyExitValue[Obj.Index] = TouchNode;\r\n//                             // 4. 更新颜色和临时状态\r\n//                             Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\r\n//                             if (this.LastKeyIndex[i] != null) {\r\n//                                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\r\n//                             }\r\n//                             //放置成功 移除节点\r\n//                             Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\r\n//                             Temp.destroyAllChildren();\r\n//                             this.KeyShadowIndex = -1;\r\n//                             // 6. 更新 UI\r\n//                             this.UpdateUIValue();\r\n//                             let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\r\n//                             await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0.2, null, \"smooth\");\r\n//                             tween(TouchNode)\r\n//                                 .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\r\n//                                 .start();\r\n//                             return;\r\n//                         }\r\n\r\n//                         if (IsExit) {\r\n//                             //放置成功 移除节点\r\n//                             Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\r\n//                             //题目节点的索引\r\n//                             let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                             let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                             console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                             console.log(this.GameData);\r\n//                             this.UpdateUIValue();\r\n//                         } else {\r\n\r\n\r\n//                             let KeyNodeIndexL: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\r\n//                             if (KeyNodeIndexL == -1) {\r\n//                                 console.log(CurrentLastKeyIndex);//有值\r\n//                                 console.log(this.LastKeyIndex[CurrentLastKeyIndex]);\r\n//                                 console.log(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\r\n//                             }\r\n\r\n//                             let KeyNodeValueL: string = \"N\";\r\n//                             this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\r\n\r\n//                             //题目节点的索引\r\n//                             let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                             let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n\r\n//                             console.log(\"赋值的索引\", KeyNodeIndexL, \"赋值的数据\", KeyNodeValueL);\r\n//                             console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                             console.log(this.GameData);\r\n\r\n//                         }\r\n//                         this.KeyExitState[Obj.Index] = true;\r\n//                         this.KeyExitValue[Obj.Index] = TouchNode;\r\n//                         if (this.LastKeyIndex[i] != null && this.LastKeyIndex[i] != Obj.Index) {\r\n//                             this.KeyExitState[this.LastKeyIndex[i]] = false;\r\n//                             this.KeyExitValue[this.LastKeyIndex[i]] = null;\r\n//                         }\r\n//                         //改变Key背景颜色\r\n//                         this.LastKeyIndex[i] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                         this.LastKeyIndex[i] = Obj.Index;\r\n\r\n//                         // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                         // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] = Obj.Index;\r\n\r\n//                         console.error(Obj.Index, this.LastKeyIndex[i], i, Value.children.indexOf(TouchNode));\r\n\r\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\r\n//                         Temp.destroyAllChildren();\r\n//                         this.KeyShadowIndex = -1;\r\n//                         let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\r\n//                         await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0, null, \"smooth\");\r\n//                         tween(TouchNode)\r\n//                             .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\r\n//                             .start();\r\n//                     } else {\r\n//                         // this.TipStart();\r\n//                         if (!IsExit) {\r\n//                             Tool_UI.instance.Arr_Increase(this.ValueTarget, TouchNode);\r\n\r\n//                             //题目节点的索引\r\n//                             let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\r\n//                             let KeyNodeValueT: string = \"N\";\r\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                             console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                             console.log(this.GameData);\r\n\r\n//                             if (this.LastKeyIndex[i] != null) {\r\n//                                 this.KeyExitState[this.LastKeyIndex[i]] = false;\r\n//                                 this.KeyExitValue[this.LastKeyIndex[i]] = null;\r\n//                                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                             }\r\n//                             // 重置当前目标位置的状态（如果之前已被占用）\r\n//                             if (this.KeyExitState[Obj.Index]) {\r\n//                                 this.KeyExitState[Obj.Index] = false;\r\n//                                 this.KeyExitValue[Obj.Index] = null;\r\n//                                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                             }\r\n\r\n\r\n//                             this.LastKeyIndex[i] = null;\r\n//                         }\r\n//                         this.UpdateUIValue();\r\n\r\n//                     }\r\n//                     console.log(\"this.KeyExitState\", this.KeyExitState);\r\n//                     console.log(\"this.KeyExitValue\", this.KeyExitValue);\r\n//                     console.log(\"this.ValueTarget\", this.ValueTarget);\r\n\r\n//                     this.FindAllEquationIndices_(this.GameData.Key);\r\n\r\n\r\n//                 });\r\n\r\n\r\n\r\n//             }\r\n\r\n\r\n\r\n//         }\r\n\r\n//         this.UpdateUIValue();\r\n\r\n//     }\r\n\r\n//     /**刷新排序 */\r\n//     UpdateUIValue() {\r\n\r\n//         this.ValueTarget.sort((a, b) => {\r\n//             const valueA = parseFloat(a.getChildByName(\"Label\").getComponent(Label).string);\r\n//             const valueB = parseFloat(b.getChildByName(\"Label\").getComponent(Label).string);\r\n//             return valueA - valueB;\r\n//         });\r\n//         for (let i = 0; i < this.ValueTarget.length; i++) {\r\n//             this.ValueTarget[i].scale = v3(1, 1, 1);\r\n//             this.ValueTarget[i].angle = 0;\r\n//             Tool_Animation.instance.Animation_Node_Move_Time(this.ValueTarget[i], this.ValuePos[i], 0.2, null, \"smooth\");\r\n//         }\r\n//     }\r\n\r\n//     async GameStart() {\r\n\r\n//         if (sys.platform === sys.Platform.WECHAT_GAME || sys.platform === sys.Platform.WECHAT_MINI_PROGRAM) {\r\n//             try {\r\n//                 window.ge.onLevelStart({ \"$user_level\": this.Game_Script.MathMatchLevel });\r\n//             } catch (error) {\r\n//                 console.log(error);\r\n\r\n//             }\r\n//         }\r\n\r\n//         this.TipReset();\r\n//         this.Timing();\r\n//         await this.InitData();\r\n//         await this.InitInterface();\r\n//         this.BtnTip.getComponent(Sprite).grayscale = this.ValueTarget.length == 0;\r\n//     }\r\n\r\n//     async GameVictory() {\r\n//         if (sys.platform === sys.Platform.WECHAT_GAME || sys.platform === sys.Platform.WECHAT_MINI_PROGRAM) {\r\n//             try {\r\n//                 window.ge.onLevelSuccess({ \"$user_level\": this.Game_Script.MathMatchLevel });\r\n//             } catch (error) {\r\n//                 console.log(error);\r\n\r\n//             }\r\n//         }\r\n\r\n//         this.Resoure_Data.Sound_Play(\"Audio/Victory\");\r\n//         this.Game_Script.TimerStop();\r\n//         this.PanelVictory.active = true;\r\n//         this.Game_Script.MathMatchLevel++;\r\n\r\n\r\n//         let T = this.GameTimeIng / this.GameTimeAll;\r\n//         this.Score = 0;\r\n//         if (T < 0.45) {\r\n//             this.Score = 3;\r\n//             this.Resoure_Data.Sound_Play(\"Audio/Start3\");\r\n//         } else if (T < 0.7) {\r\n//             this.Score = 2;\r\n//             this.Resoure_Data.Sound_Play(\"Audio/Start2\");\r\n//         } else if (T < 1) {\r\n//             this.Score = 1;\r\n//             this.Resoure_Data.Sound_Play(\"Audio/Start1\");\r\n//         } else {\r\n//             this.Score = 0;\r\n//         }\r\n\r\n//         let Stars = find(\"WinBanner/Stars\", this.PanelVictory)\r\n//         for (let I = 0; I < Stars.children.length; I++) {\r\n//             Stars.children[I].children[0].active = false;\r\n//         }\r\n//         for (let I = 0; I < this.Score; I++) {\r\n//             Stars.children[I].children[0].active = true;\r\n//         }\r\n\r\n//         this.Game_Script.MathMatchScore += this.Score;\r\n//         /**保存数据 */\r\n//         this.Game_Script.DataSet();\r\n//         // this.Game_Script.UpdateScene();\r\n//         this.Interactable = false;\r\n//         this.PanelVictory.getChildByName(\"WinBanner\").getChildByName(\"Label\").getComponent(RichText).string = `<color=#0000C8>${this.GameTimeAll}/</color><color=#C80000>${this.GameTimeIng}</color>`;\r\n\r\n\r\n//         if (this.Resoure_Data.Vibration_Switch_Get()) {\r\n//             for (let i = 0; i < 5; i++) {\r\n//                 PlatformApi.instance.vibrateShort();\r\n//                 await Tool_Animation.instance.Async_Wait(0.2);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     async GameFailed() {\r\n//         if (sys.platform === sys.Platform.WECHAT_GAME || sys.platform === sys.Platform.WECHAT_MINI_PROGRAM) {\r\n//             try {\r\n//                 window.ge.onLevelFail({ \"$user_level\": this.Game_Script.MathMatchLevel });\r\n//             } catch (error) {\r\n//                 console.log(error);\r\n\r\n//             }\r\n//         }\r\n\r\n//         this.Resoure_Data.Sound_Play(\"Audio/Failed\");\r\n//         this.PanelFail.active = true;\r\n//         this.Interactable = false;\r\n//         this.PanelFail.getChildByName(\"WinBanner\").getChildByName(\"Label\").getComponent(RichText).string = `<color=#0000C8>${this.GameTimeAll}/</color><color=#C80000>${this.GameTimeIng}</color>`;\r\n//     }\r\n\r\n//     GameResult() {\r\n\r\n\r\n//     }\r\n\r\n\r\n//     BreakNode(SetNode: Node) {\r\n\r\n//     }\r\n\r\n//     TipReset() {\r\n//         if (this.TipLabel != null) {\r\n//             this.TipLabel.getComponent(Label).string = \"\";\r\n//             this.TipLabel.scale = v3(1, 1, 1);\r\n//             Tool_Animation.instance.Tween_Stop_Target(this.TipNode);\r\n//             this.TipLabel = null;\r\n//         }\r\n//         if (this.TipNode != null) {\r\n//             Tool_Animation.instance.Tween_Stop_Target(this.TipNode);\r\n//             this.TipNode = null;\r\n//         }\r\n//     }\r\n\r\n//     TipStart(TipNode, TipLabel) {\r\n//         // if (this.TipNode != null && this.TipLabel != null) {\r\n//         // Tool_Animation.instance.Animation_Heartbeat(this.TipLabel);\r\n\r\n//         // tween(this.TipLabel)\r\n//         //     .repeatForever(\r\n//         //         tween()\r\n//         //             .to(0.2, { angle: 5 })\r\n//         //             .to(0.2, { angle: -10 })\r\n//         //             .to(0.2, { angle: 10 })\r\n//         //             .to(0.2, { angle: -10 })\r\n//         //             .to(0.2, { angle: 5 })\r\n//         //             .to(0.2, { angle: 0 })\r\n//         //             .delay(1)\r\n//         //     )\r\n//         //     .start()\r\n//         // Tool_Animation.instance.Animation_Tip(this.TipNode);\r\n\r\n//         let Key = find(\"Key\", this.node);\r\n//         let Value = find(\"Value\", this.node);\r\n//         let Temp = find(\"Temp\", this.node);\r\n//         let ColorOff: math.Color = color(255, 255, 155, 255);\r\n//         let ColorOn: math.Color = color(155, 255, 155, 255);\r\n\r\n//         this.Interactable = false;\r\n//         this.scheduleOnce(() => {\r\n//             // this.Interactable = true;\r\n//         }, 1)\r\n//         let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TipNode, TipLabel.parent);\r\n//         Tool_Animation.instance.Animation_Node_Move_Time(TipNode, Pos, 0.5, async () => {\r\n\r\n//             let TouchNode = TipNode;\r\n//             this.TouchNode = TouchNode;\r\n//             let i = this.ValueTarget.indexOf(TouchNode);\r\n\r\n//             const Shadow = Value.children[i].getChildByName(\"Shadow\");\r\n\r\n//             // for (let i = 0; i < Value.children.length; i++) {\r\n\r\n\r\n//             /**触摸结束回调 */\r\n//             Shadow.active = false;\r\n//             let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\r\n//             let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\r\n\r\n//             // 1. 获取原节点（当前占用目标位置的节点）\r\n//             const OriginalNode = this.KeyExitValue[Obj.Index];\r\n//             // 2. 将原节点移回默认位置（或 LastKeyIndex 的位置）\r\n//             //原上次索引\r\n//             let OriginalLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, OriginalNode)\r\n//             //现上次索引\r\n//             let CurrentLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, TouchNode)\r\n//             console.log(OriginalLastKeyIndex, CurrentLastKeyIndex);\r\n//             console.log(\"原上次索引\", this.LastKeyIndex[OriginalLastKeyIndex], \"现上次索引\", this.LastKeyIndex[CurrentLastKeyIndex]);\r\n\r\n//             if (Obj.Distance <= this.OnDistance) {\r\n//                 //目标位置被占用\r\n//                 if (this.KeyExitState[Obj.Index] && this.LastKeyIndex[i] != Obj.Index) {\r\n//                     if (this.LastKeyIndex[i] != null) {\r\n//                         this.KeyTarget[Obj.Index].active = false;\r\n//                         this.KeyTarget[this.LastKeyIndex[i]].active = false;\r\n//                         // 将原节点移动到 LastKeyIndex 的位置\r\n//                         const OriginalNodePos = Tool_UI.instance.Get_Target_Node_Local_Pos(OriginalNode, this.KeyTarget[this.LastKeyIndex[i]]);\r\n//                         this.Interactable = false;\r\n//                         Tool_Animation.instance.Animation_Node_Move_Time(OriginalNode, OriginalNodePos, 0.25, async () => {\r\n//                             this.Interactable = true;\r\n//                             this.KeyTarget[Obj.Index].active = true;\r\n//                             this.KeyTarget[this.LastKeyIndex[i]].active = true;\r\n//                             //交换索引\r\n\r\n//                             console.log(this.LastKeyIndex, 1);\r\n//                             console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\r\n//                             console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\r\n\r\n//                             const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\r\n//                             this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\r\n//                             this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\r\n\r\n//                             //交换节点的索引\r\n//                             let KeyNodeIndexL = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[OriginalLastKeyIndex]]);\r\n//                             let KeyNodeValueL = OriginalNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                             //题目节点的索引\r\n//                             let KeyNodeIndexT = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                             let KeyNodeValueT = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                             this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\r\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n\r\n//                             console.log(\"交换节点的索引\", KeyNodeIndexL, \"交换节点的数值\", KeyNodeValueL);\r\n//                             console.log(\"触摸节点的索引\", KeyNodeIndexT, \"触摸节点的数值\", KeyNodeValueT);\r\n//                             console.log(this.GameData);\r\n\r\n//                             this.FindAllEquationIndices_(this.GameData.Key);\r\n\r\n\r\n\r\n//                             Tool_Animation.instance.Tween_Stop_Target(OriginalNode);\r\n//                             OriginalNode.scale = v3(0.9, 0.9, 1);\r\n//                             OriginalNode.angle = 0;\r\n//                             Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                             Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n\r\n//                             // console.error(OriginalNode, TouchNode);\r\n\r\n//                             await Tool_Animation.instance.Async_Wait(0.05);\r\n//                             this.TouchNode = OriginalNode;\r\n//                             this.FindAllEquationIndices_(this.GameData.Key);\r\n\r\n//                         }, \"smooth\");\r\n//                         // 更新原节点的状态为占用 LastKeyIndex\r\n//                         this.KeyExitState[this.LastKeyIndex[i]] = true;\r\n//                         this.KeyExitValue[this.LastKeyIndex[i]] = OriginalNode;\r\n//                     } else {\r\n//                         // 如果 LastKeyIndex 为 null，将原节点放回 ValueTarget 池\r\n//                         Tool_UI.instance.Arr_Increase(this.ValueTarget, OriginalNode);\r\n\r\n//                         Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                         Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n\r\n//                         //交换索引\r\n//                         console.log(this.LastKeyIndex, 2);\r\n//                         console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\r\n//                         console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\r\n\r\n\r\n//                         const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\r\n//                         this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\r\n//                         this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\r\n\r\n//                         //题目节点的索引\r\n//                         let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                         let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                         this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                         console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                         console.log(this.GameData);\r\n\r\n\r\n//                         this.FindAllEquationIndices_(this.GameData.Key, 0.2);\r\n//                     }\r\n//                     // 3. 将新节点(TouchNode)放置到目标位置（Obj.Index）\r\n//                     this.KeyExitState[Obj.Index] = true;\r\n//                     this.KeyExitValue[Obj.Index] = TouchNode;\r\n//                     // 4. 更新颜色和临时状态\r\n//                     Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\r\n//                     if (this.LastKeyIndex[i] != null) {\r\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\r\n//                     }\r\n//                     //放置成功 移除节点\r\n//                     Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\r\n//                     Temp.destroyAllChildren();\r\n//                     this.KeyShadowIndex = -1;\r\n//                     // 6. 更新 UI\r\n//                     this.UpdateUIValue();\r\n//                     let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\r\n//                     await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0.2, null, \"smooth\");\r\n//                     tween(TouchNode)\r\n//                         .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\r\n//                         .start();\r\n//                     return;\r\n//                 }\r\n//                 if (IsExit) {\r\n//                     //放置成功 移除节点\r\n//                     Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\r\n//                     //题目节点的索引\r\n//                     let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                     let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                     console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                     console.log(this.GameData);\r\n//                     this.UpdateUIValue();\r\n//                 } else {\r\n//                     let KeyNodeIndexL: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\r\n//                     if (KeyNodeIndexL == -1) {\r\n//                         console.log(CurrentLastKeyIndex);//有值\r\n//                         console.log(this.LastKeyIndex[CurrentLastKeyIndex]);\r\n//                         console.log(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\r\n//                     }\r\n//                     let KeyNodeValueL: string = \"N\";\r\n//                     this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\r\n//                     //题目节点的索引\r\n//                     let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\r\n//                     let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\r\n//                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                     console.log(\"赋值的索引\", KeyNodeIndexL, \"赋值的数据\", KeyNodeValueL);\r\n//                     console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                     console.log(this.GameData);\r\n//                 }\r\n//                 this.KeyExitState[Obj.Index] = true;\r\n//                 this.KeyExitValue[Obj.Index] = TouchNode;\r\n//                 if (this.LastKeyIndex[i] != null && this.LastKeyIndex[i] != Obj.Index) {\r\n//                     this.KeyExitState[this.LastKeyIndex[i]] = false;\r\n//                     this.KeyExitValue[this.LastKeyIndex[i]] = null;\r\n//                 }\r\n//                 //改变Key背景颜色\r\n//                 this.LastKeyIndex[i] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                 this.LastKeyIndex[i] = Obj.Index;\r\n\r\n//                 // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                 // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] = Obj.Index;\r\n\r\n//                 console.error(Obj.Index, this.LastKeyIndex[i], i, Value.children.indexOf(TouchNode));\r\n\r\n//                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\r\n//                 Temp.destroyAllChildren();\r\n//                 this.KeyShadowIndex = -1;\r\n//                 let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\r\n//                 await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0, null, \"smooth\");\r\n//                 tween(TouchNode)\r\n//                     .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\r\n//                     .start();\r\n//             } else {\r\n//                 if (!IsExit) {\r\n//                     Tool_UI.instance.Arr_Increase(this.ValueTarget, TouchNode);\r\n//                     //题目节点的索引\r\n//                     let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\r\n//                     let KeyNodeValueT: string = \"N\";\r\n//                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\r\n//                     console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\r\n//                     console.log(this.GameData);\r\n\r\n//                     if (this.LastKeyIndex[i] != null) {\r\n//                         this.KeyExitState[this.LastKeyIndex[i]] = false;\r\n//                         this.KeyExitValue[this.LastKeyIndex[i]] = null;\r\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                     }\r\n//                     // 重置当前目标位置的状态（如果之前已被占用）\r\n//                     if (this.KeyExitState[Obj.Index]) {\r\n//                         this.KeyExitState[Obj.Index] = false;\r\n//                         this.KeyExitValue[Obj.Index] = null;\r\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\r\n//                     }\r\n\r\n\r\n//                     this.LastKeyIndex[i] = null;\r\n//                 }\r\n//                 this.UpdateUIValue();\r\n\r\n//             }\r\n//             console.log(\"this.KeyExitState\", this.KeyExitState);\r\n//             console.log(\"this.KeyExitValue\", this.KeyExitValue);\r\n//             console.log(\"this.ValueTarget\", this.ValueTarget);\r\n\r\n//             this.FindAllEquationIndices_(this.GameData.Key);\r\n\r\n//         });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//         // }\r\n//     }\r\n\r\n//     async FindAllEquationIndices_(Key: string[], Time: number = 0, Rows: number = 11, Cols: number = 11): Promise<{ CorrectIndex: number[][]; WrongIndex: number[][]; }> {\r\n\r\n//         this.TimStop();\r\n\r\n//         this.BtnTip.getComponent(Sprite).grayscale = this.ValueTarget.length == 0;\r\n\r\n//         this.Interactable = false;\r\n//         await Tool_Animation.instance.Async_Wait(Time);\r\n//         let Count = 0;\r\n//         const Result = {\r\n//             CorrectIndex: [] as number[][],\r\n//             WrongIndex: [] as number[][]\r\n//         };\r\n//         const ResultAll = {\r\n//             CorrectIndex: [] as number[],\r\n//             WrongIndex: [] as number[]\r\n//         };\r\n//         /**检查题目右边是否存在结果 */\r\n//         function CheckResult(Index: number): number {\r\n//             // return Key[Index] == \"N\" || Key[Index] == \"U\" ? null : Number(Key[Index]);\r\n//             return Key[Index] == \"N\" ? null : Number(Key[Index]);\r\n//         }\r\n//         /**计算题目左边结果 */\r\n//         function GetResult(expression: string[]): number {\r\n//             // 先处理乘除法\r\n//             const processed = [...expression];\r\n//             if (processed.indexOf(\"N\") != -1) {\r\n//                 return null;\r\n//             }\r\n//             // 第一轮处理：乘除法\r\n//             for (let i = 1; i < processed.length; i += 2) {\r\n//                 const op = processed[i];\r\n//                 if (op === \"X\" || op === \"x\" || op === \"/\") {\r\n//                     const left = parseFloat(processed[i - 1]);\r\n//                     const right = parseFloat(processed[i + 1]);\r\n//                     let result: number;\r\n//                     if (op === \"/\") {\r\n//                         if (right === 0) throw new Error(\"Division by zero\");\r\n//                         result = left / right;\r\n//                     } else {\r\n//                         result = left * right;\r\n//                     }\r\n//                     // 替换这三个元素为计算结果\r\n//                     processed.splice(i - 1, 3, result.toString());\r\n//                     i -= 2; // 因为数组长度减少了，调整索引\r\n//                 }\r\n//             }\r\n//             // 第二轮处理：加减法\r\n//             let result = parseFloat(processed[0]);\r\n//             for (let i = 1; i < processed.length; i += 2) {\r\n//                 const op = processed[i];\r\n//                 const num = parseFloat(processed[i + 1]);\r\n//                 if (op === '+') {\r\n//                     result += num;\r\n//                 } else if (op === '-') {\r\n//                     result -= num;\r\n//                 } else {\r\n//                     throw new Error(`Unknown operator: ${op}`);\r\n//                 }\r\n//             }\r\n//             return result;\r\n//         }\r\n//         let ErrorChar = [\"=\", \"U\"];\r\n//         for (let i = 0; i < Key.length; i++) {\r\n//             if (Key[i] == \"=\") {\r\n//                 // console.log(\"--------------------------------------\");\r\n//                 // console.log(\"--------------------------------------\");\r\n//                 // console.log(\"--------------------------------------\");\r\n//                 let ValueResult: number | null;\r\n//                 //水平方向\r\n//                 // console.log(\"水平方向\");\r\n\r\n//                 if (i % Rows != Rows - 1) {\r\n//                     ValueResult = CheckResult(i + 1);//*\r\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\r\n//                         let Index = i;\r\n//                         let Indexs: number[] = [];\r\n//                         let Chars: string[] = [];\r\n//                         while (Index % Rows != 0) {//*\r\n//                             Index -= 1;//*\r\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\r\n//                                 Indexs.push(Index);\r\n//                             } else {\r\n//                                 break;\r\n//                             }\r\n//                         }\r\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\r\n//                         for (let j = 0; j < Indexs.length; j++) {\r\n//                             Chars.push(Key[Indexs[j]]);\r\n//                         }\r\n//                         Indexs.push(i);\r\n//                         Indexs.push(i + 1);//*\r\n//                         let KeyResult: number = GetResult(Chars);\r\n//                         let IsEqual: boolean = KeyResult == ValueResult;\r\n//                         // console.log(Indexs);\r\n//                         // console.log(Chars);\r\n//                         // console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\r\n//                         // console.log(\"是否相等\", IsEqual);\r\n//                         if (IsEqual) {\r\n//                             Result.CorrectIndex.push(Indexs);\r\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\r\n//                             Count++\r\n//                         } else {\r\n//                             if (KeyResult != null) {\r\n//                                 Result.WrongIndex.push(Indexs);\r\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\r\n//                             }\r\n//                         }\r\n//                     }\r\n//                 }\r\n\r\n//                 if (Math.floor(i / Rows) != Cols - 1) {\r\n//                     //垂直方向\r\n//                     // console.log(\"垂直方向\");\r\n//                     ValueResult = CheckResult(i + Rows);\r\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\r\n//                         let Index = i;\r\n//                         let Indexs: number[] = [];\r\n//                         let Chars: string[] = [];\r\n//                         while (Math.floor(Index / Rows) != 0) {\r\n//                             Index -= Rows;//*\r\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\r\n//                                 Indexs.push(Index);\r\n//                             } else {\r\n//                                 break;\r\n//                             }\r\n//                         }\r\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\r\n//                         for (let j = 0; j < Indexs.length; j++) {\r\n//                             Chars.push(Key[Indexs[j]]);\r\n//                         }\r\n//                         Indexs.push(i);\r\n//                         Indexs.push(i + Rows);\r\n//                         let KeyResult: number = GetResult(Chars);\r\n//                         let IsEqual: boolean = KeyResult == ValueResult;\r\n//                         // console.log(Indexs);\r\n//                         // console.log(Chars);\r\n//                         // console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\r\n//                         // console.log(\"是否相等\", IsEqual);\r\n//                         if (IsEqual) {\r\n//                             Result.CorrectIndex.push(Indexs);\r\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\r\n//                             Count++\r\n//                         } else {\r\n//                             if (KeyResult != null) {\r\n//                                 Result.WrongIndex.push(Indexs);\r\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\r\n//                             }\r\n//                         }\r\n//                     }\r\n//                 }\r\n\r\n//                 if (i % Rows != Rows - 1 && Math.floor(i / Rows) != Cols - 1) {\r\n//                     //主对角线\r\n//                     ValueResult = CheckResult(i + (Rows + 1));\r\n//                     // console.log(\"主对角线\");\r\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\r\n//                         let Index = i;\r\n//                         let Indexs: number[] = [];\r\n//                         let Chars: string[] = [];\r\n//                         while (Index % Rows != 0) {\r\n//                             Index -= (Rows + 1);\r\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\r\n//                                 Indexs.push(Index);\r\n//                             } else {\r\n//                                 break;\r\n//                             }\r\n//                         }\r\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\r\n//                         for (let j = 0; j < Indexs.length; j++) {\r\n//                             Chars.push(Key[Indexs[j]]);\r\n//                         }\r\n//                         Indexs.push(i);\r\n//                         Indexs.push(i + (Rows + 1));\r\n//                         let KeyResult: number = GetResult(Chars);\r\n//                         let IsEqual: boolean = KeyResult == ValueResult;\r\n//                         console.log(Indexs);\r\n//                         console.log(Chars);\r\n//                         console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\r\n//                         console.log(\"是否相等\", IsEqual);\r\n//                         if (IsEqual) {\r\n//                             Result.CorrectIndex.push(Indexs);\r\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\r\n//                             Count++\r\n//                         } else {\r\n//                             if (KeyResult != null) {\r\n//                                 Result.WrongIndex.push(Indexs);\r\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\r\n//                             }\r\n//                         }\r\n//                     }\r\n//                 }\r\n\r\n\r\n\r\n//                 if (i % Rows != 0 && Math.floor(i / Rows) != Cols - 1) {\r\n//                     //副对角线\r\n//                     // console.log(\"副对角线\");\r\n//                     ValueResult = CheckResult(i + (Rows - 1));\r\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\r\n//                         let Index = i;\r\n//                         let Indexs: number[] = [];\r\n//                         let Chars: string[] = [];\r\n//                         while (Index % Rows != (Rows - 1)) {\r\n//                             Index -= (Rows - 1);\r\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\r\n//                                 Indexs.push(Index);\r\n//                             } else {\r\n//                                 break;\r\n//                             }\r\n//                         }\r\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\r\n//                         for (let j = 0; j < Indexs.length; j++) {\r\n//                             Chars.push(Key[Indexs[j]]);\r\n//                         }\r\n//                         Indexs.push(i);\r\n//                         Indexs.push(i + (Rows - 1));\r\n//                         let KeyResult: number = GetResult(Chars);\r\n//                         let IsEqual: boolean = KeyResult == ValueResult;\r\n//                         console.log(Indexs);\r\n//                         console.log(Chars);\r\n//                         console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\r\n//                         console.log(\"是否相等\", IsEqual);\r\n//                         if (IsEqual) {\r\n//                             Result.CorrectIndex.push(Indexs);\r\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\r\n//                             Count++\r\n//                         } else {\r\n//                             if (KeyResult != null) {\r\n//                                 Result.WrongIndex.push(Indexs);\r\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\r\n//                             }\r\n//                         }\r\n//                     }\r\n\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n\r\n\r\n\r\n//         let KeyP = find(\"Key\", this.node);\r\n//         let ValueP = find(\"Value\", this.node);\r\n\r\n//         let AnimReset = async () => {\r\n//             for (let i = 0; i < KeyP.children.length; i++) {\r\n//                 if (ResultAll.CorrectIndex.indexOf(i) == -1) {\r\n//                     switch (this.GameData.Key[i]) {\r\n//                         case \"N\":\r\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\"));\r\n//                             break;\r\n//                         default:\r\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\"));\r\n//                             break;\r\n//                     }\r\n//                 } else {\r\n//                     Tool_UI.instance.Arr_Delete(this.AnimCorrectNode, KeyP.children[i]);\r\n//                 }\r\n\r\n//                 if (ResultAll.WrongIndex.indexOf(i) == -1) {\r\n//                     switch (this.GameData.Key[i]) {\r\n//                         case \"N\":\r\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\"));\r\n//                             break;\r\n//                         default:\r\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\"));\r\n//                             break;\r\n//                     }\r\n//                 } else {\r\n//                     Tool_UI.instance.Arr_Delete(this.AnimWrongNode, KeyP.children[i]);\r\n//                 }\r\n\r\n//             }\r\n\r\n//             AnimV();\r\n//             AnimF();\r\n\r\n//         }\r\n\r\n//         let AnimV = async () => {\r\n//             for (let i = 0; i < Result.CorrectIndex.length; i++) {\r\n//                 for (let j = 0; j < Result.CorrectIndex[i].length; j++) {\r\n//                     if (this.AnimCorrectNode.indexOf(KeyP.children[Result.CorrectIndex[i][j]]) == -1) {\r\n//                         this.AnimCorrectNode.push(KeyP.children[Result.CorrectIndex[i][j]]);\r\n//                         Tool_UI.instance.Set_SpriteFrame(KeyP.children[Result.CorrectIndex[i][j]].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                     }\r\n//                 }\r\n//             }\r\n//             for (let i = 0; i < Result.CorrectIndex.length; i++) {\r\n//                 let ICall = async () => {\r\n//                     //上次触摸的节点在题目中\r\n//                     let IsPlay = false;\r\n\r\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(this.TouchNode.worldPosition, this.KeyTarget);\r\n//                     if (Obj.Distance <= this.OnDistance) {\r\n//                         for (let j = 0; j < Result.CorrectIndex[i].length; j++) {\r\n//                             if (this.KeyTarget[Obj.Index].name == KeyP.children[Result.CorrectIndex[i][j]].name) {\r\n//                                 IsPlay = true;\r\n//                                 console.log(\"AnimV\");\r\n//                                 break;\r\n//                             }\r\n//                         }\r\n//                     }\r\n//                     if (IsPlay) {\r\n//                         this.Resoure_Data.Sound_Play(\"Audio/Correct\");\r\n//                         for (let j = 0; j < Result.CorrectIndex[i].length; j++) {\r\n//                             //题目的Value占位节点\r\n//                             let Obj = Tool_Animation.instance.Get_Min_Distance_Node(KeyP.children[Result.CorrectIndex[i][j]].worldPosition, this.ValueTargetC);\r\n//                             if (Obj.Distance <= this.OnDistance) {\r\n//                                 Tool_UI.instance.Set_SpriteFrame(this.ValueTargetC[Obj.Index].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\r\n//                                 Tool_UI.instance.Set_Color_Label(this.ValueTargetC[Obj.Index].getChildByName(\"Label\"), color(0, 155, 0, 255));\r\n//                                 // Tool_Animation.instance.Tween_Stop_Target(this.ValueTargetC[Obj.Index]);\r\n//                                 // this.ValueTargetC[Obj.Index].scale = v3(0.9, 0.9, 1);\r\n//                                 tween(this.ValueTargetC[Obj.Index])\r\n//                                     .to(0.1, { scale: v3(0.6, 0.6, 1) })\r\n//                                     .to(0.1, { scale: v3(0.9, 0.9, 1) })\r\n//                                     .start();\r\n//                             }\r\n//                             //题目的Key占位节点\r\n//                             // Tool_Animation.instance.Tween_Stop_Target(KeyP.children[Result.CorrectIndex[i][j]]);\r\n//                             // KeyP.children[Result.CorrectIndex[i][j]].scale = v3(1, 1, 1);\r\n//                             tween(KeyP.children[Result.CorrectIndex[i][j]])\r\n//                                 .to(0.1, { scale: v3(0.6, 0.6, 1) })\r\n//                                 .to(0.1, { scale: v3(1, 1, 1) })\r\n//                                 .start();\r\n//                             await Tool_Animation.instance.Async_Wait(0.05 * Speed);\r\n//                         }\r\n//                     }\r\n//                 }\r\n//                 ICall();\r\n//             }\r\n//         }\r\n\r\n//         let AnimF = async () => {\r\n//             // for (let i = 0; i < Result.WrongIndex.length; i++) {\r\n//             //     for (let j = 0; j < Result.WrongIndex[i].length; j++) {\r\n//             //         console.error(this.AnimWrongNode.indexOf(KeyP.children[Result.WrongIndex[i][j]]));\r\n\r\n//             //         if (this.AnimWrongNode.indexOf(KeyP.children[Result.WrongIndex[i][j]]) == -1) {\r\n//             //             this.AnimWrongNode.push(KeyP.children[Result.WrongIndex[i][j]]);\r\n//             //             Tool_UI.instance.Set_SpriteFrame(KeyP.children[Result.WrongIndex[i][j]].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxE\"));\r\n//             //         }\r\n//             //     }\r\n//             // }\r\n//             for (let i = 0; i < Result.WrongIndex.length; i++) {\r\n//                 let ICall = async () => {\r\n//                     //上次触摸的节点在题目中\r\n//                     let IsPlay = false;\r\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(this.TouchNode.worldPosition, this.KeyTarget);\r\n\r\n//                     if (Obj.Distance <= this.OnDistance) {\r\n//                         for (let j = 0; j < Result.WrongIndex[i].length; j++) {\r\n//                             if (this.KeyTarget[Obj.Index].name == KeyP.children[Result.WrongIndex[i][j]].name) {\r\n//                                 IsPlay = true;\r\n//                                 console.log(\"AnimF\");\r\n//                                 break;\r\n//                             }\r\n//                         }\r\n//                     }\r\n//                     if (IsPlay) {\r\n//                         this.Resoure_Data.Sound_Play(\"Audio/Wrong\");\r\n//                         for (let j = 0; j < Result.WrongIndex[i].length; j++) {\r\n//                             //题目的Value占位节点\r\n//                             if (Number.isNaN(Number(KeyP.children[Result.WrongIndex[i][j]].getChildByName(\"Label\").getComponent(Label).string))) {\r\n//                                 continue;\r\n//                             }\r\n//                             let Obj = Tool_Animation.instance.Get_Min_Distance_Node(KeyP.children[Result.WrongIndex[i][j]].worldPosition, this.ValueTargetC);\r\n//                             if (Obj.Distance <= this.OnDistance) {\r\n//                                 Tool_UI.instance.Set_SpriteFrame(this.ValueTargetC[Obj.Index].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxE\"));\r\n//                                 Tool_UI.instance.Set_Color_Label(this.ValueTargetC[Obj.Index].getChildByName(\"Label\"), color(155, 0, 0, 255));\r\n\r\n//                                 // Tool_Animation.instance.Tween_Stop_Target(this.ValueTargetC[Obj.Index]);\r\n//                                 // Tool_Animation.instance.Tween_Stop_Target(KeyP.children[Result.WrongIndex[i][j]]);\r\n\r\n//                                 tween(this.ValueTargetC[Obj.Index])\r\n//                                     .to(0.1, { angle: 10 })\r\n//                                     .to(0.1, { angle: -20 })\r\n//                                     .to(0.1, { angle: 20 })\r\n//                                     .to(0.1, { angle: -20 })\r\n//                                     .to(0.1, { angle: 10 })\r\n//                                     .to(0.1, { angle: 0 })\r\n//                                     .start();\r\n//                                 tween(KeyP.children[Result.WrongIndex[i][j]])\r\n//                                     .to(0.1, { angle: 10 })\r\n//                                     .to(0.1, { angle: -20 })\r\n//                                     .to(0.1, { angle: 20 })\r\n//                                     .to(0.1, { angle: -20 })\r\n//                                     .to(0.1, { angle: 10 })\r\n//                                     .to(0.1, { angle: 0 })\r\n//                                     .start();\r\n//                                 // tween(this.ValueTargetC[Obj.Index])\r\n//                                 //     .by(0.1, { scale: v3(-0.4, -0.4, 1) })\r\n//                                 //     .by(0.1, { scale: v3(0.4, 0.4, 1) })\r\n//                                 //     .start();\r\n//                             }\r\n//                             //题目的Key占位节点\r\n//                             // tween(KeyP.children[Result.WrongIndex[i][j]])\r\n//                             //     .by(0.1 * Speed, { scale: v3(-0.4, - 0.4, 1) })\r\n//                             //     .by(0.1 * Speed, { scale: v3(0.4, 0.4, 1) })\r\n//                             //     .start();\r\n//                             // await Tool_Animation.instance.Async_Wait(0.05 * Speed);\r\n//                         }\r\n//                     }\r\n//                 }\r\n//                 ICall();\r\n//             }\r\n//         }\r\n\r\n\r\n//         var Speed = 1;\r\n//         await AnimReset();\r\n//         await Tool_Animation.instance.Async_Wait(0.2);\r\n//         this.Interactable = true;\r\n\r\n//         if (Count == this.GameData.Count) {\r\n//             console.log(\"胜利\");\r\n//             this.GameVictory();\r\n//         }\r\n//         Tool_Console.instance.Console_Style(Count, {\r\n//             Font_Color: 'rgba(255, 99, 71, 1)',\r\n//             Font_Size: '20px',\r\n//             Font_Weight: 'lighter',\r\n//             Font_Style: 'normal',\r\n//             Font_Family: \"'fantasy',cursive\",\r\n//             Text_Decoration: 'none',\r\n//             Text_Shadow: \"2px 2px 2px rgba(0, 0, 0, 0.5)\",\r\n//             Background_Color: 'rgba(155, 155, 155, 0.2)',\r\n//             Padding: \"10px 20px\",\r\n//             Margin: \"10px auto\",\r\n//             Border: \"1px dashed rgba(0, 255, 0, 1)\",\r\n//             Border_Radius: \"5px\",\r\n//         })\r\n\r\n\r\n//         return Result;\r\n//     }\r\n\r\n\r\n\r\n//     UpdateProp() {\r\n\r\n//         this.BtnTip.getChildByName(\"PropNum\").getChildByName(\"Label\").getComponent(Label).string = this.Game_Script.PropNum + \"\";\r\n\r\n//     }\r\n\r\n// }\r\n\r\n\r\n"]}