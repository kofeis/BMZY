{"version":3,"sources":["file:///Users/jingfaxie/Documents/UGit/ZhiShangGouBuDao/assets/Script/Game/GameMode/PanelMathMatch_.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAIA;AAIA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAYA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAIA;AAEA;AAEA;AAEA","sourcesContent":["// import { _decorator, color, Component, find, Label, Layout, log, math, Node, Prefab, Tween, tween, v3, Vec3, Animation, Sprite, RichText, sys } from 'cc';\n// import { PanelTemplate } from './PanelTemplate';\n// import { Tool_Event } from '../../Tool/Tool_Event';\n// import { Tool_Animation } from '../../Tool/Tool_Animation';\n// import { Tool_UI } from '../../Tool/Tool_UI';\n// import { Tool_Other } from '../../Tool/Tool_Other';\n// import { Tool_Console } from '../../Tool/Tool_Console';\n// import { PlatformApi } from '../../Other/SDK/PlatformApi';\n// import { GravityPlatform } from '../../Other/GeSdk/GravityPlatform';\n// const { ccclass, property } = _decorator;\n\n\n\n// /**数据接口 */\n// export interface DataMathMatch {\n//     Level: number, Key: string[], Value: number[], Result: number[], Count: number;\n// }\n\n// @ccclass('PanelMathMatch')\n// export class PanelMathMatch extends PanelTemplate {\n\n//     Interactable: boolean = true;\n\n//     GameTimeAll: number = 180;\n//     GameTimeIng: number = 0\n//     GameTime: number = 0;\n\n//     /**返回按钮 */\n//     BtnBreak: Node = null;\n//     PanelFH: Node = null;\n//     GameData: DataMathMatch = null;\n\n//     /**有效目标 */\n//     KeyTarget: Node[] = [];\n//     /**存在状态 */\n//     KeyExitState: boolean[] = [];\n\n//     /**存在节点 */\n//     KeyExitValue: Node[] = [];\n\n\n//     /**阴影索引 */\n//     KeyShadowIndex: number = -1;\n\n\n//     //Value节点上一次在Key节点的位置\n//     LastKeyIndex: number[] = [];\n//     /**有效目标 */\n//     ValueTarget: Node[] = [];\n//     ValuePos: Vec3[] = [];\n//     /**Value有效目标副本 */\n//     ValueTargetC: Node[] = [];\n\n//     KeyShadow: Prefab = null;\n//     /**有效距离 */\n//     OnDistance: number = 50;\n\n\n//     /**正确动画节点 */\n//     AnimCorrectNode: Node[] = [];\n//     /**错误动画节点 */\n//     AnimWrongNode: Node[] = [];\n//     TouchNode: Node = null;\n\n//     TipLabel: Node = null;\n//     TipNode: Node = null;\n\n\n//     Obj_Start = { num: 0 }\n//     Time: number = 0;\n//     Time_Max: number = 15;//15\n\n//     Obj_StartP = { num: 0 }\n//     TimeP: number = 0;\n//     Time_MaxP: number = 45;//45\n\n//     async onLoad() {\n//         super.onLoad();\n//     }\n\n//     async onEnable() {\n//         if (!this.IsInit) {\n//             await this.LoadPanel();\n//         }\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\")\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\")\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxE\")\n//         await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\")\n//         this.GameStart();\n//         //    this.Resoure_Data.Music_Play(\"Audio/BgmGame\");\n//     }\n\n//     start() {\n\n//     }\n\n//     Timing() {\n//         this.Obj_Start = { num: 0 };\n//         Tool_Animation.instance.Async_Function_Target(this.Time_Max, this.Obj_Start, () => {\n//             console.log(\"无操作播放\");\n//             Tool_Animation.instance.Anim_Frame_Play_Plus(this.BtnTip.getChildByName(\"Icon\").getComponent(Animation), null, null, null, null, null, 3, 0, () => {\n//                 this.Timing();\n//             });\n//         })\n//     }\n//     TimStop() {\n//         console.log(\"重置无操作播放计时\");\n//         Tool_Animation.instance.Tween_Stop_Target(this.Obj_Start);\n//         this.Timing();\n//     }\n\n//     TimingP() {\n//         this.Obj_StartP = { num: 0 };\n//         Tool_Animation.instance.Async_Function_Target(this.Time_MaxP, this.Obj_StartP, () => {\n//             console.log(\"误操作播放\");\n//             Tool_Animation.instance.Anim_Frame_Play_Plus(this.BtnTip.getChildByName(\"Icon\").getComponent(Animation), null, null, null, null, null, 3, 0, () => {\n//                 this.TimingP();\n//             });\n//         })\n//     }\n//     TimStopP() {\n//         console.log(\"重置误操作播放计时\");\n//         Tool_Animation.instance.Tween_Stop_Target(this.Obj_StartP);\n//         this.TimingP();\n//     }\n\n\n//     /**加载面板 */\n//     async LoadPanel(): Promise<void> {\n//         return new Promise(async (resolve, reject) => {\n//             /**绑定关键节点 */\n//             this.BtnSetting = find(\"BtnSetting\", this.node);\n\n//             this.PanelTip = find(\"PanelTip\", this.node);\n//             this.BtnTip = find(\"BtnTip\", this.node);\n//             this.BtnTipClose = find(\"BtnTipClose\", this.PanelTip);\n//             this.BtnTipGet = find(\"BtnTipGet\", this.PanelTip);\n\n//             this.PanelFH = find(\"PanelFH\", this.node);\n\n\n//             this.PanelVictory = find(\"PanelVictory\", this.node);\n//             this.PanelFail = find(\"PanelFail\", this.node);\n//             this.BtnNext = find(\"BtnNext\", this.PanelVictory);\n\n//             // this.BtnGet = find(\"BtnGet\", this.PanelTip);\n//             this.BtnExit = find(\"BtnExit\", this.node);\n//             /**注册按钮事件 */\n//             await this.OnBtn(this.Game_Script.AnimSwitch);\n//             this.IsInit = true;\n//             resolve();\n//             this.KeyShadow = await this.Resoure_Data.Load_Prefab(\"Prefab/PanelMathMatch/KeyShadow\");\n//         });\n//     }\n\n//     /**注册按钮 */\n//     async OnBtn(AnimSwitch: boolean = false) {\n\n//         /**设置按钮 */\n//         const BtnSettingCall = () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             this.Game_Script.UpdatePanelSetting(true);\n//         }\n\n//         /**关闭按钮 */\n//         const BtnBreakCall = () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             this.node.active = false;\n//         }\n\n//         /**重新游戏 */\n//         const BtnReStartCall = () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             PlatformApi.instance.shareAppMessage(() => { });\n//             this.Game_Script.MathMatchLevel--;\n//             this.Game_Script.MathMatchScore -= this.Score;\n//             this.Game_Script.DataSet();\n//             this.GameStart();\n//         }\n//         /**下一关按钮 */\n//         const BtnNextCall = () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             this.GameStart();\n//         }\n\n//         const BtnTipCall = async () => {\n//             if (this.ValueTarget.length == 0) {\n//                 return;\n//             }\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             if (this.Game_Script.PropNum > 0) {\n//                 TipCall();\n//             } else {\n//                 this.PanelTip.active = true;\n//             }\n\n//         }\n//         const BtnTipCloseCall = async () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             this.PanelTip.active = false;\n//         }\n//         const BtnTipGetCall = async () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             PlatformApi.instance.showVideoAd(() => {\n//                 this.Game_Script.PropNum += 200;\n//                 this.Game_Script.DataSet();\n//                 this.UpdateProp();\n//                 this.PanelTip.active = false;\n//             }, () => {\n\n//             })\n//         }\n\n\n//         /**提示 */\n//         const TipCall = async () => {\n\n//             // this.Game_Script.OnMessage(\"没有更多关卡了\");\n//             if (!this.Interactable) {\n//                 return\n//             }\n\n//             // if (this.TipLabel != null || this.TipNode != null) {\n//             //     return;\n//             // }\n\n//             //剩下的数字\n//             let ValueNumber: number[] = [];\n//             for (let i = 0; i < this.ValueTarget.length; i++) {\n//                 ValueNumber.push(Number(this.ValueTarget[i].getChildByName(\"Label\").getComponent(Label).string));\n//             }\n//             if (ValueNumber == undefined) {\n//                 this.TipLabel = null;\n//                 this.TipNode = null;\n//                 return;\n//             }\n\n//             this.Game_Script.PropNum--;\n//             this.Game_Script.DataSet();\n//             this.UpdateProp();\n\n//             console.log(\"剩下的数字\", ValueNumber);\n\n//             let NullGIndex = Tool_Other.instance.Get_Random_Int(0, ValueNumber.length - 1);\n\n//             //索引\n//             console.log(\"V索引\", NullGIndex);\n//             //答案\n//             console.log(\"答案\", ValueNumber[NullGIndex]);\n\n//             for (let j = 0; j < this.GameData.Result.length; j++) {\n//                 //如何是正确答案\n//                 if (this.GameData.Result[j] == ValueNumber[NullGIndex]) {\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(this.KeyTarget[j].worldPosition, this.ValueTargetC);\n//                     if (Obj.Distance < this.OnDistance) {\n//                         let Num = Number(this.ValueTargetC[Obj.Index].getChildByName(\"Label\").getComponent(Label).string);\n//                         console.warn(\"当前答案\", Num);\n//                         if (Num == ValueNumber[NullGIndex]) {\n//                             continue;\n//                         } else {\n//                             console.error(\"K索引\", j);\n//                             console.error(Obj);\n//                             let TipLabel = this.KeyTarget[j].getChildByName(\"Label\");\n//                             // this.TipLabel.getComponent(Label).string = ValueNumber[NullGIndex] + \"\";\n//                             // Tool_UI.instance.Set_Color_Label(this.TipLabel, color(0, 155, 0, 255));\n//                             let TipNode = this.ValueTarget[NullGIndex];\n//                             this.TipStart(TipNode, TipLabel);\n//                             let TouchNode = this.ValueTargetC[Obj.Index];\n//                             Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\n//                             let i = this.ValueTarget.indexOf(TouchNode);\n//                             let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\n//                             let Key = find(\"Key\", this.node);\n//                             let Value = find(\"Value\", this.node);\n//                             let Temp = find(\"Temp\", this.node);\n//                             let ColorOff: math.Color = color(255, 255, 155, 255);\n//                             let ColorOn: math.Color = color(155, 255, 155, 255);\n//                             Tool_Animation.instance.Tween_Stop_Target(TouchNode);\n//                             TouchNode.scale = v3(1, 1, 1);\n//                             TouchNode.angle = 0;\n//                             Tool_UI.instance.Set_SpriteFrame(TouchNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                             Tool_UI.instance.Set_Color_Label(TouchNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\n//                             Tool_UI.instance.Node_Index_Set(TouchNode, -1);\n\n//                             // 1. 获取原节点（当前占用目标位置的节点）\n//                             const OriginalNode = this.KeyExitValue[Obj.Index];\n//                             // 2. 将原节点移回默认位置（或 LastKeyIndex 的位置）\n//                             //原上次索引\n//                             let OriginalLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, OriginalNode)\n//                             //现上次索引\n//                             let CurrentLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, TouchNode)\n//                             // console.log(OriginalLastKeyIndex, CurrentLastKeyIndex);\n//                             // console.log(\"原上次索引\", this.LastKeyIndex[OriginalLastKeyIndex], \"现上次索引\", this.LastKeyIndex[CurrentLastKeyIndex]);\n\n//                             // this.TipStart();\n//                             // console.log(\"是否存在\", IsExit);\n//                             if (!IsExit) {\n//                                 Tool_UI.instance.Arr_Increase(this.ValueTarget, TouchNode);\n//                                 //题目节点的索引\n//                                 let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\n//                                 let KeyNodeValueT: string = \"N\";\n//                                 this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                                 // console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                                 // console.log(this.GameData);\n//                                 if (this.LastKeyIndex[i] != null) {\n//                                     this.KeyExitState[this.LastKeyIndex[i]] = false;\n//                                     this.KeyExitValue[this.LastKeyIndex[i]] = null;\n//                                     Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                                 }\n//                                 // 重置当前目标位置的状态（如果之前已被占用）\n//                                 if (this.KeyExitState[Obj.Index]) {\n//                                     this.KeyExitState[Obj.Index] = false;\n//                                     this.KeyExitValue[Obj.Index] = null;\n//                                     Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                                 }\n//                                 this.LastKeyIndex[i] = null;\n//                             }\n//                             this.UpdateUIValue();\n//                             return;\n//                         }\n\n//                     } else {\n//                         let TipLabel = this.KeyTarget[j].getChildByName(\"Label\");\n//                         // this.TipLabel.getComponent(Label).string = ValueNumber[NullGIndex] + \"\";\n//                         // Tool_UI.instance.Set_Color_Label(this.TipLabel, color(0, 155, 0, 255));\n//                         // console.error(\"K索引\", j);\n//                         // console.error(Obj);\n//                         let TipNode = this.ValueTarget[NullGIndex];\n\n//                         this.TipStart(TipNode, TipLabel);\n//                         return\n//                     }\n\n//                 }\n\n//             }\n\n//         }\n\n//         /**设置按钮事件 */\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnSetting, BtnSettingCall);\n\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnTip, BtnTipCall);\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnTipClose, BtnTipCloseCall);\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnTipGet, BtnTipGetCall);\n\n\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnNext, BtnNextCall);\n\n//         Tool_Event.instance.On_Event_TOUCH_END(this.BtnExit, BtnBreakCall);\n\n\n\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelVictory.getChildByName(\"BtnNext\"), BtnNextCall);\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelVictory.getChildByName(\"BtnReStart\"), BtnReStartCall);\n\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFail.getChildByName(\"BtnNext\"), BtnNextCall);\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFail.getChildByName(\"BtnBreak\"), BtnBreakCall);\n\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFH.getChildByName(\"Btn\"), () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             PlatformApi.instance.showVideoAd(() => {\n//                 this.PanelFH.active = false;\n//                 this.GameTime = this.GameTimeAll;\n//                 let ComponentLabel = find(\"Title/Bgg/Timer\", this.node).getComponent(Label);\n//                 this.Game_Script.Timer(ComponentLabel, this.GameTime, () => {\n//                     this.PanelFH.active = true;\n//                     this.Game_Script.TimerStop();\n//                 }, \"S\", () => {\n//                     this.GameTimeIng++;\n//                 });\n//             }, () => {\n\n//             })\n\n\n//         });\n//         Tool_Event.instance.On_Event_TOUCH_END(this.PanelFH.getChildByName(\"BtnClose\"), () => {\n//             this.Resoure_Data.Sound_Play(\"Audio/BtnClick\");\n//             if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                 PlatformApi.instance.vibrateShort();\n//             }\n//             this.PanelFH.active = false;\n//             this.GameFailed();\n//         });\n\n//         /**设置按钮动画 */\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnSetting, AnimSwitch);\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnTip, AnimSwitch);\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnTipClose, AnimSwitch);\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnTipGet, AnimSwitch);\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnNext, AnimSwitch);\n\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.BtnExit, AnimSwitch);\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFail.getChildByName(\"BtnNext\"), AnimSwitch);\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFail.getChildByName(\"BtnBreak\"), AnimSwitch);\n\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFH.getChildByName(\"Btn\"), AnimSwitch);\n//         Tool_Event.instance.Set_Btn_Event_Anim(this.PanelFail.getChildByName(\"BtnBreak\"), AnimSwitch);\n\n\n//         let Key = find(\"Key\", this.node);\n//         let Value = find(\"Value\", this.node);\n//         for (let i = 0; i < Value.children.length; i++) {\n//             this.ValuePos.push(Value.children[i].position.clone());\n//         }\n//     }\n\n\n//     /**初始化数据 */\n//     async InitData() {\n\n//         this.Game_Script.UpdateScore();\n\n//         console.log(\"初始化数据\");\n//         /**注册按钮事件 */\n//         // await this.OnBtn(this.Game_Script.AnimSwitch);\n//         this.KeyTarget = [];\n//         this.KeyExitState = [];\n//         this.KeyExitValue = [];\n\n//         this.ValueTarget = [];\n//         this.ValueTargetC = [];\n//         this.LastKeyIndex = [];\n\n//         this.AnimCorrectNode = [];\n//         this.AnimWrongNode = [];\n\n//         this.Interactable = true;\n\n\n\n\n//         this.TouchNode = null;\n//         this.TipLabel = null;\n//         this.TipNode = null;\n\n//         this.GameTimeIng = 0;\n\n\n//         // this.Game_Script.MathMatchLevel = 1\n\n//         if (this.Game_Script.MathMatchLevel < 0) {\n//             this.Game_Script.MathMatchLevel = 0;\n//             this.Game_Script.DataSet();\n//         }\n\n\n//         let F = {\n//             \"Level\": 6,\n//             \"Key\": [\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\",\n//                 \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\"\n//             ],\n//             \"Value\": [],\n//             \"Result\": [],\n//             \"Count\": 0\n//         }\n\n\n//         const Json = await this.Resoure_Data.Load_Json(\"Json/mathmatch\");\n//         const JsonData = Json[\"Data\"];\n//         console.log(JsonData);\n\n//         this.GameData = null;\n//         if (this.Game_Script.MathMatchLevel >= JsonData.length) {\n//             this.Game_Script.OnMessage(\"没有更多关卡了\");\n//             this.GameData = this.Resoure_Data.Copy_Deep(JsonData[JsonData.length - 1]);\n//         } else {\n//             this.GameData = this.Resoure_Data.Copy_Deep(JsonData[this.Game_Script.MathMatchLevel]);\n//         }\n//         console.log(this.GameData);\n\n//         this.Game_Script.IsHint = false;\n//         this.Game_Script.IsContinue = false;\n//         this.GameTime = this.GameTimeAll;\n//         let ComponentLabel = find(\"Title/Bgg/Timer\", this.node).getComponent(Label);\n//         this.Game_Script.Timer(ComponentLabel, this.GameTimeAll, () => {\n//             console.log(\"失败\");\n//             this.PanelFH.active = true;\n//             this.Game_Script.TimerStop();\n//         }, \"S\", () => {\n//             this.GameTimeIng++;\n//         });\n\n//     }\n\n//     /**初始化界面 */\n//     async InitInterface() {\n\n//         if (this.Game_Script.MathMatchLevel == 0) {\n//             find(\"Hand\", this.node).getComponent(Animation).play();\n//             this.Game_Script.OnMessage(\"将需要的数字拖动到空格上\");\n//         }\n//         if (this.Game_Script.MathMatchLevel == 1) {\n//             find(\"ND\", this.node).getComponent(Animation).play();\n//         }\n\n//         this.PanelVictory.active = false;\n//         this.PanelFail.active = false;\n//         this.PanelTip.active = false;\n//         this.PanelFH.active = false;\n//         this.UpdateProp();\n//         this.node.getChildByName(\"Title\").getChildByName(\"Leves\").getComponent(Label).string = `第${this.Game_Script.MathMatchLevel + 1}关`;\n//         find(\"Temp\", this.node).destroyAllChildren();\n//         let Key = find(\"Key\", this.node);\n//         let Value = find(\"Value\", this.node);\n\n//         for (let i = 0; i < Key.children.length; i++) {\n//             Key.children[i].active = false;\n//             Tool_UI.instance.Set_Color_Sprite(Key.children[i].getChildByName(\"Bg\").getChildByName(\"Sp\"), color(255, 255, 155, 255));\n//         }\n\n//         for (let i = 0; i < Value.children.length; i++) {\n//             Value.children[i].active = false;\n//             Value.children[i].scale = v3(1, 1, 1);\n//             Value.children[i].angle = 0;\n\n//             Tool_UI.instance.Set_SpriteFrame(Value.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//             Tool_UI.instance.Set_Color_Label(Value.children[i].getChildByName(\"Label\"), color(0, 155, 0, 255));\n\n//         }\n\n//         if (this.GameData == null) {\n//             console.log(\"配置错误\");\n//             return;\n//         }\n\n\n//         for (let i = 0; i < Key.children.length; i++) {\n//             Key.children[i].active = true;\n//             switch (this.GameData.Key[i]) {\n//                 case \"U\":\n//                     Key.children[i].active = false;\n//                     break;\n//                 case \"N\":\n//                     Key.children[i].getChildByName(\"Label\").getComponent(Label).string = \"\";\n//                     this.KeyTarget.push(Key.children[i]);\n//                     this.KeyExitState.push(false);\n//                     this.KeyExitValue.push(null);\n//                     Tool_UI.instance.Set_SpriteFrame(Key.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\"));\n//                     break;\n//                 default:\n//                     let Str: string = \"\";\n//                     switch (this.GameData.Key[i]) {\n//                         // case \"/\":\n//                         //     Str = \"÷\";\n//                         // break;\n//                         case \"X\":\n//                             Str = \"x\";\n//                             break;\n//                         default:\n//                             Str = this.GameData.Key[i];\n//                             break;\n//                     }\n//                     Key.children[i].getChildByName(\"Label\").getComponent(Label).string = Str\n\n//                     Tool_UI.instance.Set_SpriteFrame(Key.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\"));\n//                     break;\n//             }\n//         }\n\n//         let Temp = find(\"Temp\", this.node);\n//         let ColorOff: math.Color = color(255, 255, 155, 255);\n//         let ColorOn: math.Color = color(155, 255, 155, 255);\n\n\n//         for (let i = 0; i < Value.children.length; i++) {\n//             const Shadow = Value.children[i].getChildByName(\"Shadow\");\n//             const ComponentLabel1 = Value.children[i].getChildByName(\"Label\").getComponent(Label);\n//             Shadow.active = false;\n//             Value.children[i].active = i < this.GameData.Value.length ? true : false;\n//             if (Value.children[i].active) {\n//                 this.ValueTarget.push(Value.children[i]);\n//                 this.ValueTargetC.push(Value.children[i]);\n//                 this.LastKeyIndex.push(null);\n//                 Value.children[i].position = this.ValuePos[i];\n//                 ComponentLabel1.string = this.GameData.Value[i] + \"\";\n\n//                 Tool_Event.instance.Off_Event_TOUCH_All(Value.children[i]);\n\n\n\n//                 const TouchNode = Value.children[i];\n//                 const Shadow = TouchNode.getChildByName(\"Shadow\");\n//                 const ComponentLabel = TouchNode.getChildByName(\"Label\").getComponent(Label);\n//                 const Check_Shadow = () => {\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\n//                     if (Obj.Distance <= this.OnDistance) {\n//                         if (this.KeyShadowIndex == Obj.Index) {\n//                             return;\n//                         }\n//                         Temp.destroyAllChildren();\n//                         this.KeyShadowIndex = Obj.Index;\n//                         Tool_UI.instance.Set_Prefab_Node(this.KeyShadow, Temp, this.KeyTarget[Obj.Index], \"\")\n//                     } else {\n//                         Temp.destroyAllChildren();\n//                         this.KeyShadowIndex = -1;\n//                     }\n//                 }\n\n\n//                 Tool_Event.instance.On_Event_TOUCH_Drag(TouchNode, () => this.Interactable, async (Event, Pos_Touch_Start) => {\n//                     if (this.GameData == null) {\n//                         this.Interactable = false;\n//                         console.log(\"配置错误\");\n//                         return;\n//                     }\n//                     this.TouchNode = TouchNode;\n//                     console.log(this.LastKeyIndex, i, this.ValueTargetC.indexOf(TouchNode));\n//                     /**触摸开始回调 */\n//                     this.Resoure_Data.Sound_Play(\"Audio/NumClick\");\n//                     if (this.Resoure_Data.Vibration_Switch_Get()) {\n//                         PlatformApi.instance.vibrateShort();\n//                     }\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\n//                     Tool_Animation.instance.Tween_Stop_Target(this.KeyTarget[Obj.Index]);\n//                     this.KeyTarget[Obj.Index].scale = v3(1, 1, 1);\n//                     this.KeyTarget[Obj.Index].angle = 0;\n//                     Tool_Animation.instance.Tween_Stop_Target(TouchNode);\n//                     TouchNode.scale = v3(1, 1, 1);\n//                     TouchNode.angle = 0;\n//                     Tool_UI.instance.Set_SpriteFrame(TouchNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                     Tool_UI.instance.Set_Color_Label(TouchNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\n\n//                     Tool_UI.instance.Node_Index_Set(TouchNode, -1);\n//                     Shadow.active = true;\n//                     Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos_Touch_Start.clone().add(v3(0, 25, 0)), 0.02, null, \"smooth\");\n//                     let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\n//                     if (!IsExit) {\n//                         tween(TouchNode)\n//                             .to(0.25, { scale: v3(1, 1, 1) }, { easing: \"backOut\" })\n//                             .start();\n//                     }\n//                     Check_Shadow();\n//                 }, (Event, Pos_Touch_Start) => {\n//                     /**触摸移动回调 */\n//                     Check_Shadow();\n//                 }, async (Event, Pos_Touch_Start, Pos_Touch_End) => {\n//                     /**触摸结束回调 */\n//                     Shadow.active = false;\n//                     let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\n\n//                     // 1. 获取原节点（当前占用目标位置的节点）\n//                     const OriginalNode = this.KeyExitValue[Obj.Index];\n//                     // 2. 将原节点移回默认位置（或 LastKeyIndex 的位置）\n//                     //原上次索引\n//                     let OriginalLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, OriginalNode)\n//                     //现上次索引\n//                     let CurrentLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, TouchNode)\n//                     console.log(OriginalLastKeyIndex, CurrentLastKeyIndex);\n//                     console.log(\"原上次索引\", this.LastKeyIndex[OriginalLastKeyIndex], \"现上次索引\", this.LastKeyIndex[CurrentLastKeyIndex]);\n\n//                     if (Obj.Distance <= this.OnDistance) {\n\n//                         // this.TipReset();\n\n//                         //目标位置被占用\n//                         if (this.KeyExitState[Obj.Index] && this.LastKeyIndex[i] != Obj.Index) {\n//                             if (this.LastKeyIndex[i] != null) {\n//                                 this.KeyTarget[Obj.Index].active = false;\n//                                 this.KeyTarget[this.LastKeyIndex[i]].active = false;\n//                                 // 将原节点移动到 LastKeyIndex 的位置\n//                                 const OriginalNodePos = Tool_UI.instance.Get_Target_Node_Local_Pos(OriginalNode, this.KeyTarget[this.LastKeyIndex[i]]);\n//                                 this.Interactable = false;\n//                                 Tool_Animation.instance.Animation_Node_Move_Time(OriginalNode, OriginalNodePos, 0.25, async () => {\n//                                     this.Interactable = true;\n//                                     this.KeyTarget[Obj.Index].active = true;\n//                                     this.KeyTarget[this.LastKeyIndex[i]].active = true;\n//                                     //交换索引\n\n//                                     console.log(this.LastKeyIndex, 1);\n//                                     console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\n//                                     console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\n\n//                                     const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\n//                                     this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\n//                                     this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\n\n//                                     //交换节点的索引\n//                                     let KeyNodeIndexL = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[OriginalLastKeyIndex]]);\n//                                     let KeyNodeValueL = OriginalNode.getChildByName(\"Label\").getComponent(Label).string;\n//                                     //题目节点的索引\n//                                     let KeyNodeIndexT = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                                     let KeyNodeValueT = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                                     this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\n//                                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n\n//                                     console.log(\"交换节点的索引\", KeyNodeIndexL, \"交换节点的数值\", KeyNodeValueL);\n//                                     console.log(\"触摸节点的索引\", KeyNodeIndexT, \"触摸节点的数值\", KeyNodeValueT);\n//                                     console.log(this.GameData);\n\n//                                     this.FindAllEquationIndices_(this.GameData.Key);\n\n\n\n//                                     Tool_Animation.instance.Tween_Stop_Target(OriginalNode);\n//                                     OriginalNode.scale = v3(0.9, 0.9, 1);\n//                                     OriginalNode.angle = 0;\n//                                     Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                                     Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\n\n//                                     // console.error(OriginalNode, TouchNode);\n\n//                                     await Tool_Animation.instance.Async_Wait(0.05);\n//                                     this.TouchNode = OriginalNode;\n//                                     this.FindAllEquationIndices_(this.GameData.Key);\n\n//                                 }, \"smooth\");\n//                                 // 更新原节点的状态为占用 LastKeyIndex\n//                                 this.KeyExitState[this.LastKeyIndex[i]] = true;\n//                                 this.KeyExitValue[this.LastKeyIndex[i]] = OriginalNode;\n//                             } else {\n//                                 // 如果 LastKeyIndex 为 null，将原节点放回 ValueTarget 池\n//                                 Tool_UI.instance.Arr_Increase(this.ValueTarget, OriginalNode);\n\n//                                 Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                                 Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\n\n//                                 //交换索引\n//                                 console.log(this.LastKeyIndex, 2);\n//                                 console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\n//                                 console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\n\n\n//                                 const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\n//                                 this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\n//                                 this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\n\n//                                 //题目节点的索引\n//                                 let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                                 let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                                 this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                                 console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                                 console.log(this.GameData);\n\n\n//                                 this.FindAllEquationIndices_(this.GameData.Key, 0.2);\n//                             }\n//                             // 3. 将新节点(TouchNode)放置到目标位置（Obj.Index）\n//                             this.KeyExitState[Obj.Index] = true;\n//                             this.KeyExitValue[Obj.Index] = TouchNode;\n//                             // 4. 更新颜色和临时状态\n//                             Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\n//                             if (this.LastKeyIndex[i] != null) {\n//                                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\n//                             }\n//                             //放置成功 移除节点\n//                             Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\n//                             Temp.destroyAllChildren();\n//                             this.KeyShadowIndex = -1;\n//                             // 6. 更新 UI\n//                             this.UpdateUIValue();\n//                             let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\n//                             await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0.2, null, \"smooth\");\n//                             tween(TouchNode)\n//                                 .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\n//                                 .start();\n//                             return;\n//                         }\n\n//                         if (IsExit) {\n//                             //放置成功 移除节点\n//                             Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\n//                             //题目节点的索引\n//                             let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                             let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                             console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                             console.log(this.GameData);\n//                             this.UpdateUIValue();\n//                         } else {\n\n\n//                             let KeyNodeIndexL: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\n//                             if (KeyNodeIndexL == -1) {\n//                                 console.log(CurrentLastKeyIndex);//有值\n//                                 console.log(this.LastKeyIndex[CurrentLastKeyIndex]);\n//                                 console.log(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\n//                             }\n\n//                             let KeyNodeValueL: string = \"N\";\n//                             this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\n\n//                             //题目节点的索引\n//                             let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                             let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n\n//                             console.log(\"赋值的索引\", KeyNodeIndexL, \"赋值的数据\", KeyNodeValueL);\n//                             console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                             console.log(this.GameData);\n\n//                         }\n//                         this.KeyExitState[Obj.Index] = true;\n//                         this.KeyExitValue[Obj.Index] = TouchNode;\n//                         if (this.LastKeyIndex[i] != null && this.LastKeyIndex[i] != Obj.Index) {\n//                             this.KeyExitState[this.LastKeyIndex[i]] = false;\n//                             this.KeyExitValue[this.LastKeyIndex[i]] = null;\n//                         }\n//                         //改变Key背景颜色\n//                         this.LastKeyIndex[i] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                         this.LastKeyIndex[i] = Obj.Index;\n\n//                         // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                         // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] = Obj.Index;\n\n//                         console.error(Obj.Index, this.LastKeyIndex[i], i, Value.children.indexOf(TouchNode));\n\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\n//                         Temp.destroyAllChildren();\n//                         this.KeyShadowIndex = -1;\n//                         let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\n//                         await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0, null, \"smooth\");\n//                         tween(TouchNode)\n//                             .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\n//                             .start();\n//                     } else {\n//                         // this.TipStart();\n//                         if (!IsExit) {\n//                             Tool_UI.instance.Arr_Increase(this.ValueTarget, TouchNode);\n\n//                             //题目节点的索引\n//                             let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\n//                             let KeyNodeValueT: string = \"N\";\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                             console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                             console.log(this.GameData);\n\n//                             if (this.LastKeyIndex[i] != null) {\n//                                 this.KeyExitState[this.LastKeyIndex[i]] = false;\n//                                 this.KeyExitValue[this.LastKeyIndex[i]] = null;\n//                                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                             }\n//                             // 重置当前目标位置的状态（如果之前已被占用）\n//                             if (this.KeyExitState[Obj.Index]) {\n//                                 this.KeyExitState[Obj.Index] = false;\n//                                 this.KeyExitValue[Obj.Index] = null;\n//                                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                             }\n\n\n//                             this.LastKeyIndex[i] = null;\n//                         }\n//                         this.UpdateUIValue();\n\n//                     }\n//                     console.log(\"this.KeyExitState\", this.KeyExitState);\n//                     console.log(\"this.KeyExitValue\", this.KeyExitValue);\n//                     console.log(\"this.ValueTarget\", this.ValueTarget);\n\n//                     this.FindAllEquationIndices_(this.GameData.Key);\n\n\n//                 });\n\n\n\n//             }\n\n\n\n//         }\n\n//         this.UpdateUIValue();\n\n//     }\n\n//     /**刷新排序 */\n//     UpdateUIValue() {\n\n//         this.ValueTarget.sort((a, b) => {\n//             const valueA = parseFloat(a.getChildByName(\"Label\").getComponent(Label).string);\n//             const valueB = parseFloat(b.getChildByName(\"Label\").getComponent(Label).string);\n//             return valueA - valueB;\n//         });\n//         for (let i = 0; i < this.ValueTarget.length; i++) {\n//             this.ValueTarget[i].scale = v3(1, 1, 1);\n//             this.ValueTarget[i].angle = 0;\n//             Tool_Animation.instance.Animation_Node_Move_Time(this.ValueTarget[i], this.ValuePos[i], 0.2, null, \"smooth\");\n//         }\n//     }\n\n//     async GameStart() {\n\n//         if (sys.platform === sys.Platform.WECHAT_GAME || sys.platform === sys.Platform.WECHAT_MINI_PROGRAM) {\n//             try {\n//                 window.ge.onLevelStart({ \"$user_level\": this.Game_Script.MathMatchLevel });\n//             } catch (error) {\n//                 console.log(error);\n\n//             }\n//         }\n\n//         this.TipReset();\n//         this.Timing();\n//         await this.InitData();\n//         await this.InitInterface();\n//         this.BtnTip.getComponent(Sprite).grayscale = this.ValueTarget.length == 0;\n//     }\n\n//     async GameVictory() {\n//         if (sys.platform === sys.Platform.WECHAT_GAME || sys.platform === sys.Platform.WECHAT_MINI_PROGRAM) {\n//             try {\n//                 window.ge.onLevelSuccess({ \"$user_level\": this.Game_Script.MathMatchLevel });\n//             } catch (error) {\n//                 console.log(error);\n\n//             }\n//         }\n\n//         this.Resoure_Data.Sound_Play(\"Audio/Victory\");\n//         this.Game_Script.TimerStop();\n//         this.PanelVictory.active = true;\n//         this.Game_Script.MathMatchLevel++;\n\n\n//         let T = this.GameTimeIng / this.GameTimeAll;\n//         this.Score = 0;\n//         if (T < 0.45) {\n//             this.Score = 3;\n//             this.Resoure_Data.Sound_Play(\"Audio/Start3\");\n//         } else if (T < 0.7) {\n//             this.Score = 2;\n//             this.Resoure_Data.Sound_Play(\"Audio/Start2\");\n//         } else if (T < 1) {\n//             this.Score = 1;\n//             this.Resoure_Data.Sound_Play(\"Audio/Start1\");\n//         } else {\n//             this.Score = 0;\n//         }\n\n//         let Stars = find(\"WinBanner/Stars\", this.PanelVictory)\n//         for (let I = 0; I < Stars.children.length; I++) {\n//             Stars.children[I].children[0].active = false;\n//         }\n//         for (let I = 0; I < this.Score; I++) {\n//             Stars.children[I].children[0].active = true;\n//         }\n\n//         this.Game_Script.MathMatchScore += this.Score;\n//         /**保存数据 */\n//         this.Game_Script.DataSet();\n//         // this.Game_Script.UpdateScene();\n//         this.Interactable = false;\n//         this.PanelVictory.getChildByName(\"WinBanner\").getChildByName(\"Label\").getComponent(RichText).string = `<color=#0000C8>${this.GameTimeAll}/</color><color=#C80000>${this.GameTimeIng}</color>`;\n\n\n//         if (this.Resoure_Data.Vibration_Switch_Get()) {\n//             for (let i = 0; i < 5; i++) {\n//                 PlatformApi.instance.vibrateShort();\n//                 await Tool_Animation.instance.Async_Wait(0.2);\n//             }\n//         }\n//     }\n\n//     async GameFailed() {\n//         if (sys.platform === sys.Platform.WECHAT_GAME || sys.platform === sys.Platform.WECHAT_MINI_PROGRAM) {\n//             try {\n//                 window.ge.onLevelFail({ \"$user_level\": this.Game_Script.MathMatchLevel });\n//             } catch (error) {\n//                 console.log(error);\n\n//             }\n//         }\n\n//         this.Resoure_Data.Sound_Play(\"Audio/Failed\");\n//         this.PanelFail.active = true;\n//         this.Interactable = false;\n//         this.PanelFail.getChildByName(\"WinBanner\").getChildByName(\"Label\").getComponent(RichText).string = `<color=#0000C8>${this.GameTimeAll}/</color><color=#C80000>${this.GameTimeIng}</color>`;\n//     }\n\n//     GameResult() {\n\n\n//     }\n\n\n//     BreakNode(SetNode: Node) {\n\n//     }\n\n//     TipReset() {\n//         if (this.TipLabel != null) {\n//             this.TipLabel.getComponent(Label).string = \"\";\n//             this.TipLabel.scale = v3(1, 1, 1);\n//             Tool_Animation.instance.Tween_Stop_Target(this.TipNode);\n//             this.TipLabel = null;\n//         }\n//         if (this.TipNode != null) {\n//             Tool_Animation.instance.Tween_Stop_Target(this.TipNode);\n//             this.TipNode = null;\n//         }\n//     }\n\n//     TipStart(TipNode, TipLabel) {\n//         // if (this.TipNode != null && this.TipLabel != null) {\n//         // Tool_Animation.instance.Animation_Heartbeat(this.TipLabel);\n\n//         // tween(this.TipLabel)\n//         //     .repeatForever(\n//         //         tween()\n//         //             .to(0.2, { angle: 5 })\n//         //             .to(0.2, { angle: -10 })\n//         //             .to(0.2, { angle: 10 })\n//         //             .to(0.2, { angle: -10 })\n//         //             .to(0.2, { angle: 5 })\n//         //             .to(0.2, { angle: 0 })\n//         //             .delay(1)\n//         //     )\n//         //     .start()\n//         // Tool_Animation.instance.Animation_Tip(this.TipNode);\n\n//         let Key = find(\"Key\", this.node);\n//         let Value = find(\"Value\", this.node);\n//         let Temp = find(\"Temp\", this.node);\n//         let ColorOff: math.Color = color(255, 255, 155, 255);\n//         let ColorOn: math.Color = color(155, 255, 155, 255);\n\n//         this.Interactable = false;\n//         this.scheduleOnce(() => {\n//             // this.Interactable = true;\n//         }, 1)\n//         let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TipNode, TipLabel.parent);\n//         Tool_Animation.instance.Animation_Node_Move_Time(TipNode, Pos, 0.5, async () => {\n\n//             let TouchNode = TipNode;\n//             this.TouchNode = TouchNode;\n//             let i = this.ValueTarget.indexOf(TouchNode);\n\n//             const Shadow = Value.children[i].getChildByName(\"Shadow\");\n\n//             // for (let i = 0; i < Value.children.length; i++) {\n\n\n//             /**触摸结束回调 */\n//             Shadow.active = false;\n//             let IsExit: boolean = Tool_UI.instance.Arr_Check_Index(this.ValueTarget, TouchNode) == -1 ? false : true;\n//             let Obj = Tool_Animation.instance.Get_Min_Distance_Node(TouchNode.worldPosition, this.KeyTarget);\n\n//             // 1. 获取原节点（当前占用目标位置的节点）\n//             const OriginalNode = this.KeyExitValue[Obj.Index];\n//             // 2. 将原节点移回默认位置（或 LastKeyIndex 的位置）\n//             //原上次索引\n//             let OriginalLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, OriginalNode)\n//             //现上次索引\n//             let CurrentLastKeyIndex = Tool_UI.instance.Arr_Check_Index(this.ValueTargetC, TouchNode)\n//             console.log(OriginalLastKeyIndex, CurrentLastKeyIndex);\n//             console.log(\"原上次索引\", this.LastKeyIndex[OriginalLastKeyIndex], \"现上次索引\", this.LastKeyIndex[CurrentLastKeyIndex]);\n\n//             if (Obj.Distance <= this.OnDistance) {\n//                 //目标位置被占用\n//                 if (this.KeyExitState[Obj.Index] && this.LastKeyIndex[i] != Obj.Index) {\n//                     if (this.LastKeyIndex[i] != null) {\n//                         this.KeyTarget[Obj.Index].active = false;\n//                         this.KeyTarget[this.LastKeyIndex[i]].active = false;\n//                         // 将原节点移动到 LastKeyIndex 的位置\n//                         const OriginalNodePos = Tool_UI.instance.Get_Target_Node_Local_Pos(OriginalNode, this.KeyTarget[this.LastKeyIndex[i]]);\n//                         this.Interactable = false;\n//                         Tool_Animation.instance.Animation_Node_Move_Time(OriginalNode, OriginalNodePos, 0.25, async () => {\n//                             this.Interactable = true;\n//                             this.KeyTarget[Obj.Index].active = true;\n//                             this.KeyTarget[this.LastKeyIndex[i]].active = true;\n//                             //交换索引\n\n//                             console.log(this.LastKeyIndex, 1);\n//                             console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\n//                             console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\n\n//                             const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\n//                             this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\n//                             this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\n\n//                             //交换节点的索引\n//                             let KeyNodeIndexL = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[OriginalLastKeyIndex]]);\n//                             let KeyNodeValueL = OriginalNode.getChildByName(\"Label\").getComponent(Label).string;\n//                             //题目节点的索引\n//                             let KeyNodeIndexT = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                             let KeyNodeValueT = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                             this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\n//                             this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n\n//                             console.log(\"交换节点的索引\", KeyNodeIndexL, \"交换节点的数值\", KeyNodeValueL);\n//                             console.log(\"触摸节点的索引\", KeyNodeIndexT, \"触摸节点的数值\", KeyNodeValueT);\n//                             console.log(this.GameData);\n\n//                             this.FindAllEquationIndices_(this.GameData.Key);\n\n\n\n//                             Tool_Animation.instance.Tween_Stop_Target(OriginalNode);\n//                             OriginalNode.scale = v3(0.9, 0.9, 1);\n//                             OriginalNode.angle = 0;\n//                             Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                             Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\n\n//                             // console.error(OriginalNode, TouchNode);\n\n//                             await Tool_Animation.instance.Async_Wait(0.05);\n//                             this.TouchNode = OriginalNode;\n//                             this.FindAllEquationIndices_(this.GameData.Key);\n\n//                         }, \"smooth\");\n//                         // 更新原节点的状态为占用 LastKeyIndex\n//                         this.KeyExitState[this.LastKeyIndex[i]] = true;\n//                         this.KeyExitValue[this.LastKeyIndex[i]] = OriginalNode;\n//                     } else {\n//                         // 如果 LastKeyIndex 为 null，将原节点放回 ValueTarget 池\n//                         Tool_UI.instance.Arr_Increase(this.ValueTarget, OriginalNode);\n\n//                         Tool_UI.instance.Set_SpriteFrame(OriginalNode.getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                         Tool_UI.instance.Set_Color_Label(OriginalNode.getChildByName(\"Label\"), color(0, 155, 0, 255));\n\n//                         //交换索引\n//                         console.log(this.LastKeyIndex, 2);\n//                         console.error(OriginalLastKeyIndex, this.LastKeyIndex[OriginalLastKeyIndex]);\n//                         console.error(CurrentLastKeyIndex, this.LastKeyIndex[CurrentLastKeyIndex]);\n\n\n//                         const LastKeyIndexTemp = this.LastKeyIndex[OriginalLastKeyIndex];\n//                         this.LastKeyIndex[OriginalLastKeyIndex] = this.LastKeyIndex[CurrentLastKeyIndex];\n//                         this.LastKeyIndex[CurrentLastKeyIndex] = LastKeyIndexTemp;\n\n//                         //题目节点的索引\n//                         let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                         let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                         this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                         console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                         console.log(this.GameData);\n\n\n//                         this.FindAllEquationIndices_(this.GameData.Key, 0.2);\n//                     }\n//                     // 3. 将新节点(TouchNode)放置到目标位置（Obj.Index）\n//                     this.KeyExitState[Obj.Index] = true;\n//                     this.KeyExitValue[Obj.Index] = TouchNode;\n//                     // 4. 更新颜色和临时状态\n//                     Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\n//                     if (this.LastKeyIndex[i] != null) {\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\n//                     }\n//                     //放置成功 移除节点\n//                     Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\n//                     Temp.destroyAllChildren();\n//                     this.KeyShadowIndex = -1;\n//                     // 6. 更新 UI\n//                     this.UpdateUIValue();\n//                     let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\n//                     await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0.2, null, \"smooth\");\n//                     tween(TouchNode)\n//                         .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\n//                         .start();\n//                     return;\n//                 }\n//                 if (IsExit) {\n//                     //放置成功 移除节点\n//                     Tool_UI.instance.Arr_Delete(this.ValueTarget, TouchNode);\n//                     //题目节点的索引\n//                     let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                     let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                     console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                     console.log(this.GameData);\n//                     this.UpdateUIValue();\n//                 } else {\n//                     let KeyNodeIndexL: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\n//                     if (KeyNodeIndexL == -1) {\n//                         console.log(CurrentLastKeyIndex);//有值\n//                         console.log(this.LastKeyIndex[CurrentLastKeyIndex]);\n//                         console.log(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\n//                     }\n//                     let KeyNodeValueL: string = \"N\";\n//                     this.GameData.Key[KeyNodeIndexL] = KeyNodeValueL;\n//                     //题目节点的索引\n//                     let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[Obj.Index]);\n//                     let KeyNodeValueT: string = TouchNode.getChildByName(\"Label\").getComponent(Label).string;\n//                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                     console.log(\"赋值的索引\", KeyNodeIndexL, \"赋值的数据\", KeyNodeValueL);\n//                     console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                     console.log(this.GameData);\n//                 }\n//                 this.KeyExitState[Obj.Index] = true;\n//                 this.KeyExitValue[Obj.Index] = TouchNode;\n//                 if (this.LastKeyIndex[i] != null && this.LastKeyIndex[i] != Obj.Index) {\n//                     this.KeyExitState[this.LastKeyIndex[i]] = false;\n//                     this.KeyExitValue[this.LastKeyIndex[i]] = null;\n//                 }\n//                 //改变Key背景颜色\n//                 this.LastKeyIndex[i] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                 this.LastKeyIndex[i] = Obj.Index;\n\n//                 // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] != null && Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                 // this.LastKeyIndex[this.ValueTargetC.indexOf(TouchNode)] = Obj.Index;\n\n//                 console.error(Obj.Index, this.LastKeyIndex[i], i, Value.children.indexOf(TouchNode));\n\n//                 Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOn);\n//                 Temp.destroyAllChildren();\n//                 this.KeyShadowIndex = -1;\n//                 let Pos = Tool_UI.instance.Get_Target_Node_Local_Pos(TouchNode, this.KeyTarget[Obj.Index]);\n//                 await Tool_Animation.instance.Animation_Node_Move_Time(TouchNode, Pos, 0, null, \"smooth\");\n//                 tween(TouchNode)\n//                     .to(0.25, { scale: v3(0.9, 0.9, 1) }, { easing: \"backOut\" })\n//                     .start();\n//             } else {\n//                 if (!IsExit) {\n//                     Tool_UI.instance.Arr_Increase(this.ValueTarget, TouchNode);\n//                     //题目节点的索引\n//                     let KeyNodeIndexT: number = Key.children.indexOf(this.KeyTarget[this.LastKeyIndex[CurrentLastKeyIndex]]);\n//                     let KeyNodeValueT: string = \"N\";\n//                     this.GameData.Key[KeyNodeIndexT] = KeyNodeValueT;\n//                     console.log(\"赋值的索引\", KeyNodeIndexT, \"赋值的数据\", KeyNodeValueT);\n//                     console.log(this.GameData);\n\n//                     if (this.LastKeyIndex[i] != null) {\n//                         this.KeyExitState[this.LastKeyIndex[i]] = false;\n//                         this.KeyExitValue[this.LastKeyIndex[i]] = null;\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[this.LastKeyIndex[i]].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                     }\n//                     // 重置当前目标位置的状态（如果之前已被占用）\n//                     if (this.KeyExitState[Obj.Index]) {\n//                         this.KeyExitState[Obj.Index] = false;\n//                         this.KeyExitValue[Obj.Index] = null;\n//                         Tool_UI.instance.Set_Color_Sprite(this.KeyTarget[Obj.Index].getChildByName(\"Bg\").getChildByName(\"Sp\"), ColorOff);\n//                     }\n\n\n//                     this.LastKeyIndex[i] = null;\n//                 }\n//                 this.UpdateUIValue();\n\n//             }\n//             console.log(\"this.KeyExitState\", this.KeyExitState);\n//             console.log(\"this.KeyExitValue\", this.KeyExitValue);\n//             console.log(\"this.ValueTarget\", this.ValueTarget);\n\n//             this.FindAllEquationIndices_(this.GameData.Key);\n\n//         });\n\n\n\n\n\n\n\n\n\n\n\n//         // }\n//     }\n\n//     async FindAllEquationIndices_(Key: string[], Time: number = 0, Rows: number = 11, Cols: number = 11): Promise<{ CorrectIndex: number[][]; WrongIndex: number[][]; }> {\n\n//         this.TimStop();\n\n//         this.BtnTip.getComponent(Sprite).grayscale = this.ValueTarget.length == 0;\n\n//         this.Interactable = false;\n//         await Tool_Animation.instance.Async_Wait(Time);\n//         let Count = 0;\n//         const Result = {\n//             CorrectIndex: [] as number[][],\n//             WrongIndex: [] as number[][]\n//         };\n//         const ResultAll = {\n//             CorrectIndex: [] as number[],\n//             WrongIndex: [] as number[]\n//         };\n//         /**检查题目右边是否存在结果 */\n//         function CheckResult(Index: number): number {\n//             // return Key[Index] == \"N\" || Key[Index] == \"U\" ? null : Number(Key[Index]);\n//             return Key[Index] == \"N\" ? null : Number(Key[Index]);\n//         }\n//         /**计算题目左边结果 */\n//         function GetResult(expression: string[]): number {\n//             // 先处理乘除法\n//             const processed = [...expression];\n//             if (processed.indexOf(\"N\") != -1) {\n//                 return null;\n//             }\n//             // 第一轮处理：乘除法\n//             for (let i = 1; i < processed.length; i += 2) {\n//                 const op = processed[i];\n//                 if (op === \"X\" || op === \"x\" || op === \"/\") {\n//                     const left = parseFloat(processed[i - 1]);\n//                     const right = parseFloat(processed[i + 1]);\n//                     let result: number;\n//                     if (op === \"/\") {\n//                         if (right === 0) throw new Error(\"Division by zero\");\n//                         result = left / right;\n//                     } else {\n//                         result = left * right;\n//                     }\n//                     // 替换这三个元素为计算结果\n//                     processed.splice(i - 1, 3, result.toString());\n//                     i -= 2; // 因为数组长度减少了，调整索引\n//                 }\n//             }\n//             // 第二轮处理：加减法\n//             let result = parseFloat(processed[0]);\n//             for (let i = 1; i < processed.length; i += 2) {\n//                 const op = processed[i];\n//                 const num = parseFloat(processed[i + 1]);\n//                 if (op === '+') {\n//                     result += num;\n//                 } else if (op === '-') {\n//                     result -= num;\n//                 } else {\n//                     throw new Error(`Unknown operator: ${op}`);\n//                 }\n//             }\n//             return result;\n//         }\n//         let ErrorChar = [\"=\", \"U\"];\n//         for (let i = 0; i < Key.length; i++) {\n//             if (Key[i] == \"=\") {\n//                 // console.log(\"--------------------------------------\");\n//                 // console.log(\"--------------------------------------\");\n//                 // console.log(\"--------------------------------------\");\n//                 let ValueResult: number | null;\n//                 //水平方向\n//                 // console.log(\"水平方向\");\n\n//                 if (i % Rows != Rows - 1) {\n//                     ValueResult = CheckResult(i + 1);//*\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\n//                         let Index = i;\n//                         let Indexs: number[] = [];\n//                         let Chars: string[] = [];\n//                         while (Index % Rows != 0) {//*\n//                             Index -= 1;//*\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\n//                                 Indexs.push(Index);\n//                             } else {\n//                                 break;\n//                             }\n//                         }\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\n//                         for (let j = 0; j < Indexs.length; j++) {\n//                             Chars.push(Key[Indexs[j]]);\n//                         }\n//                         Indexs.push(i);\n//                         Indexs.push(i + 1);//*\n//                         let KeyResult: number = GetResult(Chars);\n//                         let IsEqual: boolean = KeyResult == ValueResult;\n//                         // console.log(Indexs);\n//                         // console.log(Chars);\n//                         // console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\n//                         // console.log(\"是否相等\", IsEqual);\n//                         if (IsEqual) {\n//                             Result.CorrectIndex.push(Indexs);\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\n//                             Count++\n//                         } else {\n//                             if (KeyResult != null) {\n//                                 Result.WrongIndex.push(Indexs);\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\n//                             }\n//                         }\n//                     }\n//                 }\n\n//                 if (Math.floor(i / Rows) != Cols - 1) {\n//                     //垂直方向\n//                     // console.log(\"垂直方向\");\n//                     ValueResult = CheckResult(i + Rows);\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\n//                         let Index = i;\n//                         let Indexs: number[] = [];\n//                         let Chars: string[] = [];\n//                         while (Math.floor(Index / Rows) != 0) {\n//                             Index -= Rows;//*\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\n//                                 Indexs.push(Index);\n//                             } else {\n//                                 break;\n//                             }\n//                         }\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\n//                         for (let j = 0; j < Indexs.length; j++) {\n//                             Chars.push(Key[Indexs[j]]);\n//                         }\n//                         Indexs.push(i);\n//                         Indexs.push(i + Rows);\n//                         let KeyResult: number = GetResult(Chars);\n//                         let IsEqual: boolean = KeyResult == ValueResult;\n//                         // console.log(Indexs);\n//                         // console.log(Chars);\n//                         // console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\n//                         // console.log(\"是否相等\", IsEqual);\n//                         if (IsEqual) {\n//                             Result.CorrectIndex.push(Indexs);\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\n//                             Count++\n//                         } else {\n//                             if (KeyResult != null) {\n//                                 Result.WrongIndex.push(Indexs);\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\n//                             }\n//                         }\n//                     }\n//                 }\n\n//                 if (i % Rows != Rows - 1 && Math.floor(i / Rows) != Cols - 1) {\n//                     //主对角线\n//                     ValueResult = CheckResult(i + (Rows + 1));\n//                     // console.log(\"主对角线\");\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\n//                         let Index = i;\n//                         let Indexs: number[] = [];\n//                         let Chars: string[] = [];\n//                         while (Index % Rows != 0) {\n//                             Index -= (Rows + 1);\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\n//                                 Indexs.push(Index);\n//                             } else {\n//                                 break;\n//                             }\n//                         }\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\n//                         for (let j = 0; j < Indexs.length; j++) {\n//                             Chars.push(Key[Indexs[j]]);\n//                         }\n//                         Indexs.push(i);\n//                         Indexs.push(i + (Rows + 1));\n//                         let KeyResult: number = GetResult(Chars);\n//                         let IsEqual: boolean = KeyResult == ValueResult;\n//                         console.log(Indexs);\n//                         console.log(Chars);\n//                         console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\n//                         console.log(\"是否相等\", IsEqual);\n//                         if (IsEqual) {\n//                             Result.CorrectIndex.push(Indexs);\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\n//                             Count++\n//                         } else {\n//                             if (KeyResult != null) {\n//                                 Result.WrongIndex.push(Indexs);\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\n//                             }\n//                         }\n//                     }\n//                 }\n\n\n\n//                 if (i % Rows != 0 && Math.floor(i / Rows) != Cols - 1) {\n//                     //副对角线\n//                     // console.log(\"副对角线\");\n//                     ValueResult = CheckResult(i + (Rows - 1));\n//                     if (ValueResult != null && !Number.isNaN(ValueResult)) {\n//                         let Index = i;\n//                         let Indexs: number[] = [];\n//                         let Chars: string[] = [];\n//                         while (Index % Rows != (Rows - 1)) {\n//                             Index -= (Rows - 1);\n//                             if (ErrorChar.indexOf(Key[Index]) == -1) {\n//                                 Indexs.push(Index);\n//                             } else {\n//                                 break;\n//                             }\n//                         }\n//                         Tool_Other.instance.Sort_Reverse(Indexs);\n//                         for (let j = 0; j < Indexs.length; j++) {\n//                             Chars.push(Key[Indexs[j]]);\n//                         }\n//                         Indexs.push(i);\n//                         Indexs.push(i + (Rows - 1));\n//                         let KeyResult: number = GetResult(Chars);\n//                         let IsEqual: boolean = KeyResult == ValueResult;\n//                         console.log(Indexs);\n//                         console.log(Chars);\n//                         console.log(\"ValueResult\", ValueResult, \"KeyResult\", KeyResult);\n//                         console.log(\"是否相等\", IsEqual);\n//                         if (IsEqual) {\n//                             Result.CorrectIndex.push(Indexs);\n//                             ResultAll.CorrectIndex = [...ResultAll.CorrectIndex, ...Indexs];\n//                             Count++\n//                         } else {\n//                             if (KeyResult != null) {\n//                                 Result.WrongIndex.push(Indexs);\n//                                 ResultAll.WrongIndex = [...ResultAll.WrongIndex, ...Indexs];\n//                             }\n//                         }\n//                     }\n\n//                 }\n//             }\n//         }\n\n\n\n\n//         let KeyP = find(\"Key\", this.node);\n//         let ValueP = find(\"Value\", this.node);\n\n//         let AnimReset = async () => {\n//             for (let i = 0; i < KeyP.children.length; i++) {\n//                 if (ResultAll.CorrectIndex.indexOf(i) == -1) {\n//                     switch (this.GameData.Key[i]) {\n//                         case \"N\":\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\"));\n//                             break;\n//                         default:\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\"));\n//                             break;\n//                     }\n//                 } else {\n//                     Tool_UI.instance.Arr_Delete(this.AnimCorrectNode, KeyP.children[i]);\n//                 }\n\n//                 if (ResultAll.WrongIndex.indexOf(i) == -1) {\n//                     switch (this.GameData.Key[i]) {\n//                         case \"N\":\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxN\"));\n//                             break;\n//                         default:\n//                             Tool_UI.instance.Set_SpriteFrame(KeyP.children[i].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxU\"));\n//                             break;\n//                     }\n//                 } else {\n//                     Tool_UI.instance.Arr_Delete(this.AnimWrongNode, KeyP.children[i]);\n//                 }\n\n//             }\n\n//             AnimV();\n//             AnimF();\n\n//         }\n\n//         let AnimV = async () => {\n//             for (let i = 0; i < Result.CorrectIndex.length; i++) {\n//                 for (let j = 0; j < Result.CorrectIndex[i].length; j++) {\n//                     if (this.AnimCorrectNode.indexOf(KeyP.children[Result.CorrectIndex[i][j]]) == -1) {\n//                         this.AnimCorrectNode.push(KeyP.children[Result.CorrectIndex[i][j]]);\n//                         Tool_UI.instance.Set_SpriteFrame(KeyP.children[Result.CorrectIndex[i][j]].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                     }\n//                 }\n//             }\n//             for (let i = 0; i < Result.CorrectIndex.length; i++) {\n//                 let ICall = async () => {\n//                     //上次触摸的节点在题目中\n//                     let IsPlay = false;\n\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(this.TouchNode.worldPosition, this.KeyTarget);\n//                     if (Obj.Distance <= this.OnDistance) {\n//                         for (let j = 0; j < Result.CorrectIndex[i].length; j++) {\n//                             if (this.KeyTarget[Obj.Index].name == KeyP.children[Result.CorrectIndex[i][j]].name) {\n//                                 IsPlay = true;\n//                                 console.log(\"AnimV\");\n//                                 break;\n//                             }\n//                         }\n//                     }\n//                     if (IsPlay) {\n//                         this.Resoure_Data.Sound_Play(\"Audio/Correct\");\n//                         for (let j = 0; j < Result.CorrectIndex[i].length; j++) {\n//                             //题目的Value占位节点\n//                             let Obj = Tool_Animation.instance.Get_Min_Distance_Node(KeyP.children[Result.CorrectIndex[i][j]].worldPosition, this.ValueTargetC);\n//                             if (Obj.Distance <= this.OnDistance) {\n//                                 Tool_UI.instance.Set_SpriteFrame(this.ValueTargetC[Obj.Index].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxC\"));\n//                                 Tool_UI.instance.Set_Color_Label(this.ValueTargetC[Obj.Index].getChildByName(\"Label\"), color(0, 155, 0, 255));\n//                                 // Tool_Animation.instance.Tween_Stop_Target(this.ValueTargetC[Obj.Index]);\n//                                 // this.ValueTargetC[Obj.Index].scale = v3(0.9, 0.9, 1);\n//                                 tween(this.ValueTargetC[Obj.Index])\n//                                     .to(0.1, { scale: v3(0.6, 0.6, 1) })\n//                                     .to(0.1, { scale: v3(0.9, 0.9, 1) })\n//                                     .start();\n//                             }\n//                             //题目的Key占位节点\n//                             // Tool_Animation.instance.Tween_Stop_Target(KeyP.children[Result.CorrectIndex[i][j]]);\n//                             // KeyP.children[Result.CorrectIndex[i][j]].scale = v3(1, 1, 1);\n//                             tween(KeyP.children[Result.CorrectIndex[i][j]])\n//                                 .to(0.1, { scale: v3(0.6, 0.6, 1) })\n//                                 .to(0.1, { scale: v3(1, 1, 1) })\n//                                 .start();\n//                             await Tool_Animation.instance.Async_Wait(0.05 * Speed);\n//                         }\n//                     }\n//                 }\n//                 ICall();\n//             }\n//         }\n\n//         let AnimF = async () => {\n//             // for (let i = 0; i < Result.WrongIndex.length; i++) {\n//             //     for (let j = 0; j < Result.WrongIndex[i].length; j++) {\n//             //         console.error(this.AnimWrongNode.indexOf(KeyP.children[Result.WrongIndex[i][j]]));\n\n//             //         if (this.AnimWrongNode.indexOf(KeyP.children[Result.WrongIndex[i][j]]) == -1) {\n//             //             this.AnimWrongNode.push(KeyP.children[Result.WrongIndex[i][j]]);\n//             //             Tool_UI.instance.Set_SpriteFrame(KeyP.children[Result.WrongIndex[i][j]].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxE\"));\n//             //         }\n//             //     }\n//             // }\n//             for (let i = 0; i < Result.WrongIndex.length; i++) {\n//                 let ICall = async () => {\n//                     //上次触摸的节点在题目中\n//                     let IsPlay = false;\n//                     let Obj = Tool_Animation.instance.Get_Min_Distance_Node(this.TouchNode.worldPosition, this.KeyTarget);\n\n//                     if (Obj.Distance <= this.OnDistance) {\n//                         for (let j = 0; j < Result.WrongIndex[i].length; j++) {\n//                             if (this.KeyTarget[Obj.Index].name == KeyP.children[Result.WrongIndex[i][j]].name) {\n//                                 IsPlay = true;\n//                                 console.log(\"AnimF\");\n//                                 break;\n//                             }\n//                         }\n//                     }\n//                     if (IsPlay) {\n//                         this.Resoure_Data.Sound_Play(\"Audio/Wrong\");\n//                         for (let j = 0; j < Result.WrongIndex[i].length; j++) {\n//                             //题目的Value占位节点\n//                             if (Number.isNaN(Number(KeyP.children[Result.WrongIndex[i][j]].getChildByName(\"Label\").getComponent(Label).string))) {\n//                                 continue;\n//                             }\n//                             let Obj = Tool_Animation.instance.Get_Min_Distance_Node(KeyP.children[Result.WrongIndex[i][j]].worldPosition, this.ValueTargetC);\n//                             if (Obj.Distance <= this.OnDistance) {\n//                                 Tool_UI.instance.Set_SpriteFrame(this.ValueTargetC[Obj.Index].getChildByName(\"Bg\"), await this.Resoure_Data.Load_SpriteFrame(\"SpriteFrame/Panel/PanelMathMatch/BoxE\"));\n//                                 Tool_UI.instance.Set_Color_Label(this.ValueTargetC[Obj.Index].getChildByName(\"Label\"), color(155, 0, 0, 255));\n\n//                                 // Tool_Animation.instance.Tween_Stop_Target(this.ValueTargetC[Obj.Index]);\n//                                 // Tool_Animation.instance.Tween_Stop_Target(KeyP.children[Result.WrongIndex[i][j]]);\n\n//                                 tween(this.ValueTargetC[Obj.Index])\n//                                     .to(0.1, { angle: 10 })\n//                                     .to(0.1, { angle: -20 })\n//                                     .to(0.1, { angle: 20 })\n//                                     .to(0.1, { angle: -20 })\n//                                     .to(0.1, { angle: 10 })\n//                                     .to(0.1, { angle: 0 })\n//                                     .start();\n//                                 tween(KeyP.children[Result.WrongIndex[i][j]])\n//                                     .to(0.1, { angle: 10 })\n//                                     .to(0.1, { angle: -20 })\n//                                     .to(0.1, { angle: 20 })\n//                                     .to(0.1, { angle: -20 })\n//                                     .to(0.1, { angle: 10 })\n//                                     .to(0.1, { angle: 0 })\n//                                     .start();\n//                                 // tween(this.ValueTargetC[Obj.Index])\n//                                 //     .by(0.1, { scale: v3(-0.4, -0.4, 1) })\n//                                 //     .by(0.1, { scale: v3(0.4, 0.4, 1) })\n//                                 //     .start();\n//                             }\n//                             //题目的Key占位节点\n//                             // tween(KeyP.children[Result.WrongIndex[i][j]])\n//                             //     .by(0.1 * Speed, { scale: v3(-0.4, - 0.4, 1) })\n//                             //     .by(0.1 * Speed, { scale: v3(0.4, 0.4, 1) })\n//                             //     .start();\n//                             // await Tool_Animation.instance.Async_Wait(0.05 * Speed);\n//                         }\n//                     }\n//                 }\n//                 ICall();\n//             }\n//         }\n\n\n//         var Speed = 1;\n//         await AnimReset();\n//         await Tool_Animation.instance.Async_Wait(0.2);\n//         this.Interactable = true;\n\n//         if (Count == this.GameData.Count) {\n//             console.log(\"胜利\");\n//             this.GameVictory();\n//         }\n//         Tool_Console.instance.Console_Style(Count, {\n//             Font_Color: 'rgba(255, 99, 71, 1)',\n//             Font_Size: '20px',\n//             Font_Weight: 'lighter',\n//             Font_Style: 'normal',\n//             Font_Family: \"'fantasy',cursive\",\n//             Text_Decoration: 'none',\n//             Text_Shadow: \"2px 2px 2px rgba(0, 0, 0, 0.5)\",\n//             Background_Color: 'rgba(155, 155, 155, 0.2)',\n//             Padding: \"10px 20px\",\n//             Margin: \"10px auto\",\n//             Border: \"1px dashed rgba(0, 255, 0, 1)\",\n//             Border_Radius: \"5px\",\n//         })\n\n\n//         return Result;\n//     }\n\n\n\n//     UpdateProp() {\n\n//         this.BtnTip.getChildByName(\"PropNum\").getChildByName(\"Label\").getComponent(Label).string = this.Game_Script.PropNum + \"\";\n\n//     }\n\n// }\n\n\n"]}